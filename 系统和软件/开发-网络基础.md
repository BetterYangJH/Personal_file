*   协议：OSI七层模型(PDU协议数据包，需要和别人通讯时才有)
    *   应用层：控制应用程序，为应用提供网络服务
        *   协议：telnet，ssh，http，https，ftp，smtp，rip
    *   表示层：格式化数据，加密
        *   协议：ascii，jpeg，png，mp3，wav，avi
    *   会话层：控制会话
        *   协议：NFS，SQL，windows
    *   传输层：会话建立和网络传输
        *   协议：rcp，udp，spx
        *   PDU：fragment段
    *   网络层：路由器，定义寻址逻辑，选择传输路径和路由包
        *   协议：IP，IPX
        *   PDU：packet数据包
    *   链路层：交换机，根据Mac地址转发数据，逻辑链路控制
        *   协议：以太网，帧中继
        *   PDU：frame帧
    *   物理层：集线器
        *   协议：电器机械规范
        *   PDU：bit

*   TCP/IP协议族
    *   TCP：传输前和到达后数据和Ip包转换
    *   IP：因特网上发送接受数据包
    *   HTTP：web服务端和浏览器之间通信
    *   HTTPS：Secure层
    *   SSL：安全数据加密传输
    *   FTP：文件传输
    *   NTP：计算机间时间同步
    *   PPTP：私人网络连接隧道

*   ssh通道-secure shell

    ssl协议-secure socket layer

*   request获取请求参数

    response设置响应参数
    
*   流程

    *   客户机会将请求封装成http数据包-->封装成Tcp数据包-->封装成Ip数据包--->封装成数据帧--->硬件将帧数据转换成bit流（二进制数据）-->最后通过物理硬件（网卡芯片）发送到指定地点。
    *   服务器硬件首先收到bit流....... 然后转换成ip数据包。于是通过ip协议解析Ip数据包，然后又发现里面是tcp数据包，就通过tcp协议解析Tcp数据包，接着发现是http数据包通过http协议再解析http数据包得到数据。

*   传输层

    *   TCP

        *   面向连接
        *   特征：无丢失，无失序，无差错，无重复

        *   情况：文件下载

        *   缺点：粘包(添加消息边界/控制发送速度)

        *   实现： 在通信前需要建立数据连接，通信结束要正常断开连接。

        ```python
        # 三次握手（建立连接）
        >客户端向服务器发送消息报文请求连接
         SYN=1，seq=x
        >服务器收到请求后，回复报文确定可以连接
         SYN=1，seq=y，ACK=1，ack=x+1
        >客户端收到回复，发送最终报文连接建立
         	    seq=x+1，ACK=1，ack=y+1
         
        # 四次挥手（断开连接）
        >主动方发送报文请求断开连接
         FIN=1，seq=u
        >被动方收到请求后，立即回复，表示准备断开
         ACK=1，seq=v，ack=u+1
        >被动方准备就绪，再次发送报文表示可以断开
         FIN=1，ACK=1，seq=w，ack=u+1
        >主动方收到确定，发送最终报文完成断开
         ACK=1，seq=u+1，ack=w+1
        ```

    * UDP

        *   面向无连接
        *   特征：不保证传输可靠性，数据收发自由，没有连接断开
        *   情况：网络差，可靠低，视频，群聊，广播
        *   缺点：稳定性，数据丢失

    * 题目

        * 为什么连接的时候是三次握手，关闭的时候却是四次握手？

            答：断开连接前需要确认现有任务处理完毕。因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

        *   为什么不能用两次握手进行连接？

            答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。把三次握手改成仅需要两次握手可能发生死锁：假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

        *   如果已经建立了连接，但是客户端突然出现故障了怎么办？

            答：心跳检测。TCP还设有一个保活计时器，时间通常是设置为2小时。服务器每收到一次客户端的请求后都会重新复位这个计时器，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段。以后每隔75秒钟发送一次。若发送10个探测报文仍没反应，服务器就认为客户端出了故障并关闭连接。
