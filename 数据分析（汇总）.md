

**设置当前窗口的参数**

语法：测试窗口相关参数

```python
# 设置图表标题 显示在图表上方
mp.title(title, fontsize=12)
# 设置水平轴的文本
mp.xlabel(x_label_str, fontsize=12)
# 设置垂直轴的文本
mp.ylabel(y_label_str, fontsize=12)
# 设置图表网格线  linestyle设置网格线的样式
	#	-  or solid 粗线
	#   -- or dashed 虚线
	#   -. or dashdot 点虚线
	#   :  or dotted 点线
mp.grid(linestyle='')
# 设置紧凑布局，把图表相关参数都显示在窗口中
mp.tight_layout() 
```

示例：绘制两个图像窗口

```python
# 绘制两个图像窗口
import matplotlib.pyplot as mp

mp.figure("FigureA", facecolor="lightgray")
mp.grid(linestyle="-.")  # 设置网格线

mp.figure("FigureB", facecolor="gray")
mp.xlabel("Date", fontsize=14)
mp.ylabel("Price", fontsize=14)
mp.grid(linestyle="--")  # 设置网格线
mp.tight_layout()  # 设置紧凑布局

mp.show()
```

执行结果：

![](images/两个窗口.png)

#### 1）子图

**矩阵式布局**

效果：

![](C:/Users/xuming/Desktop/20.02%E7%A0%94%E5%8F%91/%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%99/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/images/9%E4%B8%AA%E5%AD%90%E5%9B%BE.png)



绘制矩阵式子图布局相关API：

```python
mp.figure('Subplot Layout', facecolor='lightgray')
# 拆分矩阵
	# rows:	行数
    # cols:	列数
    # num:	编号
mp.subplot(rows, cols, num)
	#	1 2 3
	#	4 5 6
	#	7 8 9 
mp.subplot(3, 3, 5)		#操作3*3的矩阵中编号为5的子图
mp.subplot(335)			#简写

```

案例：绘制9宫格矩阵式子图，每个子图中写一个数字。

```python
mp.figure('Subplot Layout', facecolor='lightgray')

for i in range(9):
	mp.subplot(3, 3, i+1)
	mp.text(
		0.5, 0.5, i+1, 
		ha='center',
		va='center',
		size=36,
		alpha=0.5,
		withdash=False
	)
	mp.xticks([])
	mp.yticks([])

mp.tight_layout()
mp.show()

```

**网格式布局(很少使用)**

网格式布局支持单元格的合并。

绘制网格式子图布局相关API：

```python
import matplotlib.gridspec as mg
mp.figure('Grid Layout', facecolor='lightgray')
# 调用GridSpec方法拆分网格式布局
# rows:	行数
# cols:	列数
# gs = mg.GridSpec(rows, cols)	拆分成3行3列
gs = mg.GridSpec(3, 3)	
# 合并0行与0、1列为一个子图表
mp.subplot(gs[0, :2])
mp.text(0.5, 0.5, '1', ha='center', va='center', size=36)
mp.show()

```

案例：绘制一个自定义网格布局。

```python
import matplotlib.gridspec as mg
mp.figure('GridLayout', facecolor='lightgray')
gridsubs = mp.GridSpec(3, 3)
# 合并0行、0/1列为一个子图
mp.subplot(gridsubs[0, :2])
mp.text(0.5, 0.5, 1, ha='center', va='center', size=36)
mp.tight_layout()
mp.xticks([])
mp.yticks([])

```

**自由式布局(很少使用)**

自由式布局相关API：

```python
mp.figure('Flow Layout', facecolor='lightgray')
# 设置图标的位置，给出左下角点坐标与宽高即可
# left_bottom_x: 坐下角点x坐标
# left_bottom_x: 坐下角点y坐标
# width:		 宽度
# height:		 高度
# mp.axes([left_bottom_x, left_bottom_y, width, height])
mp.axes([0.03, 0.03, 0.94, 0.94])
mp.text(0.5, 0.5, '1', ha='center', va='center', size=36)
mp.show()

```

案例：测试自由式布局，定位子图。

```python
mp.figure('FlowLayout', facecolor='lightgray')

mp.axes([0.1, 0.2, 0.5, 0.3])
mp.text(0.5, 0.5, 1, ha='center', va='center', size=36)
mp.show()

```

#### 2）刻度定位器

执行结果：

![主刻度次刻度](C:/Users/xuming/Desktop/20.02%E7%A0%94%E5%8F%91/%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%99/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/images/%E4%B8%BB%E5%88%BB%E5%BA%A6%E6%AC%A1%E5%88%BB%E5%BA%A6.png)



刻度定位器相关API：

```python
# 获取当前坐标轴
ax = mp.gca()
# 设置水平坐标轴的主刻度（显示字的刻度）定位器
ax.xaxis.set_major_locator(mp.NullLocator())
# 设置水平坐标轴的次刻度（不显示字的刻度）定位器为多点定位器，间隔0.1
ax.xaxis.set_minor_locator(mp.MultipleLocator(0.1))

```

案例：绘制一个数轴，每隔1一个主刻度，每隔0.1一个次刻度。

```python
import matplotlib.pyplot as mp

mp.figure('Locators', facecolor='lightgray')
# 获取当前坐标轴
ax = mp.gca()

# 隐藏除底轴以外的所有坐标轴
ax.spines['left'].set_color('none')
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')

# 将底坐标轴调整到子图中心位置
ax.spines['bottom'].set_position(('data', 0))
# 设置水平坐标轴的主刻度定位器
ax.xaxis.set_major_locator(mp.MultipleLocator(1))
# 设置水平坐标轴的次刻度定位器为多点定位器，间隔0.1
ax.xaxis.set_minor_locator(mp.MultipleLocator(0.1))

mp.xlim(1, 5)
# 标记所用刻度定位器类名
mp.text(5, 0.3, 'NullLocator()', ha='center', size=12)

mp.show()
```

常用刻度器如下：

```python
# 空定位器：不绘制刻度
mp.NullLocator()
# 最大值定位器：
# 最多绘制nbins+1个刻度
mp.MaxNLocator(nbins=3)
# 定点定位器：根据locs参数中的位置绘制刻度
mp.FixedLocator(locs=[0, 2.5, 5, 7.5, 10])
# 自动定位器：由系统自动选择刻度的绘制位置
mp.AutoLocator()
# 索引定位器：由offset确定起始刻度，由base确定相邻刻度的间隔
mp.IndexLocator(offset=0.5, base=1.5)
# 多点定位器：从0开始，按照参数指定的间隔(缺省1)绘制刻度
mp.MultipleLocator()
# 线性定位器：等分numticks-1份，绘制numticks个刻度
mp.LinearLocator(numticks=21)
# 对数定位器：以base为底，绘制刻度
mp.LogLocator(base=2)
```

案例：使用for循环测试刻度器样式：

```python
import matplotlib.pyplot as mp
import numpy as np

locators = ['mp.NullLocator()', # 空刻度定位器，不绘制刻度
            'mp.MultipleLocator(1)', # 多点定位器：从0开始，按照参数指定的间隔(缺省1)绘制
            'mp.MaxNLocator(nbins=4)',# 最多绘制指定个数+1个主刻度
            'mp.AutoLocator()'] # 自动定位器：由系统自动选择刻度的绘制位置

for i, locator in enumerate(locators):
    mp.subplot(len(locators), 1, i + 1)
    mp.xlim(0, 10)
    mp.ylim(-1, 1)
    mp.yticks([])
    # 获取当前坐标轴
    ax = mp.gca()
    # 隐藏除底轴以外的所有坐标轴
    ax.spines['left'].set_color('none')
    ax.spines['top'].set_color('none')
    ax.spines['right'].set_color('none')
    # 将底坐标轴调整到子图中心位置
    ax.spines['bottom'].set_position(('data', 0))
    # 设置水平坐标轴的主刻度定位器
    ax.xaxis.set_major_locator(eval(locator))
    # 设置水平坐标轴的次刻度定位器为多点定位器，间隔0.1
    ax.xaxis.set_minor_locator(mp.MultipleLocator(0.1))
    mp.plot(np.arange(11), np.zeros(11), c='none')
    # 标记所用刻度定位器类名
    mp.text(5, 0.3, locator, ha='center', size=12)

mp.show()
```

执行结果：

![](images/多个刻度定位器.png)

#### 3）散点图

可以通过每个点的坐标、颜色、大小和形状表示不同的特征值。

| 身高 | 体重 | 性别 | 年龄段 | 种族 |
| ---- | ---- | ---- | ------ | ---- |
| 180  | 80   | 男   | 中年   | 亚洲 |
| 160  | 50   | 女   | 青少   | 美洲 |

绘制散点图的相关API：

```python
mp.scatter(
    x, 					# x轴坐标数组
    y,					# y轴坐标数组
    marker='', 			# 点型
    s=10,				# 大小
    color='',			# 颜色
    edgecolor='', 		# 边缘颜色
    facecolor='',		# 填充色
    zorder=''			# 图层序号
)

```

numpy.random提供了normal函数用于产生符合 正态分布 的随机数 

```python
n = 100
# 172:	期望值
# 10:	标准差
# n:	数字生成数量
x = np.random.normal(172, 20, n)
y = np.random.normal(60, 10, n)

```

案例：绘制平面散点图。

```python
# 散点图示例
import matplotlib.pyplot as mp
import numpy as np

n = 40
# 期望值：期望值是该变量输出值的平均数
# 标准差：是反映一组数据离散程度最常用的一种量化形式，是表示精确度的重要指标
x = np.random.normal(172, 20 ,n ) # 期望值, 标准差, 生成数量
y = np.random.normal(60, 10, n) # 期望值, 标准差, 生成数量

x2 = np.random.normal(180, 20 ,n ) # 期望值, 标准差, 生成数量
y2 = np.random.normal(70, 10, n) # 期望值, 标准差, 生成数量

mp.figure("scatter", facecolor="lightgray")
mp.title("Scatter Demo")
mp.scatter(x, y, c="red", marker="D")
mp.scatter(x2, y2, c="blue", marker="v")

mp.xlim(100, 240)
mp.ylim(0, 100)
mp.show()
```

执行结果：

![](images/散点图示例.png)

*cmap颜色映射表参照附件：cmap颜色映射表*

#### 4）填充

执行结果：

![](images/区域填充示例.png)

以某种颜色自动填充两条曲线的闭合区域。

```python
mp.fill_between(
	x,				# x轴的水平坐标
    sin_x,			# 下边界曲线上点的垂直坐标
    cos_x,			# 上边界曲线上点的垂直坐标
    sin_x<cos_x, 	# 填充条件，为True时填充
    color='', 		# 填充颜色
    alpha=0.2		# 透明度
)
```

案例：绘制两条曲线： sin_x = sin(x)    cos_x = cos(x / 2) / 2	[0-8π]  

```python
import matplotlib.pyplot as mp
import numpy as np

n = 1000
x = np.linspace(0, 8 * np.pi, n)  # 返回指定间隔上的等距数字

sin_y = np.sin(x)  # 计算sin函数值
cos_y = np.cos(x / 2) / 2  # 计算cos函数值

mp.figure('Fill', facecolor='lightgray')
mp.title('Fill', fontsize=20)
mp.xlabel('x', fontsize=14)  # x轴标签
mp.ylabel('y', fontsize=14)  # y轴
mp.tick_params(labelsize=10)  # 刻度
mp.grid(linestyle=':')

mp.plot(x, sin_y, c='dodgerblue', label=r'$y=sin(x)$')
mp.plot(x, cos_y, c='orangered', label=r'$y=\frac{1}{2}cos(\frac{x}{2})$')

# 填充cos_y < sin_y的部分
mp.fill_between(x, cos_y, sin_y, cos_y < sin_y, color='dodgerblue', alpha=0.5)
# 填充cos_y > sin_y的部分
mp.fill_between(x, cos_y, sin_y, cos_y > sin_y, color='orangered', alpha=0.5)

mp.legend()
mp.show()
```

#### 5）条形图（柱状图）

绘制柱状图的相关API：

```python
mp.figure('Bar', facecolor='lightgray')
mp.bar(
	x,				# 水平坐标数组
    y,				# 柱状图高度数组
    width,			# 柱子的宽度
    color='', 		# 填充颜色
    label='',		#
    alpha=0.2		#
)
```

案例：先以柱状图绘制苹果12个月的销量，然后再绘制橘子的销量。

```python
import matplotlib.pyplot as mp
import numpy as np

apples = np.array([30, 25, 22, 36, 21, 29, 20, 24, 33, 19, 27, 15])
oranges = np.array([24, 33, 19, 27, 35, 20, 15, 27, 20, 32, 20, 22])

mp.figure('Bar', facecolor='lightgray')
mp.title('Bar', fontsize=20)
mp.xlabel('Month', fontsize=14)
mp.ylabel('Price', fontsize=14)
mp.tick_params(labelsize=10)
mp.grid(axis='y', linestyle=':')
mp.ylim((0, 40))

x = np.arange(len(apples))  # 产生均匀数组，长度等同于apples

mp.bar(x - 0.2,  # 横轴数据
       apples,  # 纵轴数据
       0.4,  # 柱体宽度
       color='dodgerblue',
       label='Apple')
mp.bar(x + 0.2,  # 横轴数据
       oranges,  # 纵轴数据
       0.4,  # 柱体宽度
       color='orangered', label='Orange', alpha=0.75)

mp.xticks(x, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])

mp.legend()
mp.show()
```

#### 6）统计直方图

执行结果：

![](images/hist.png)

绘制直方图相关API：

```python
mp.hist(
    x, 					# 值列表		
    bins, 				# 直方柱数量
    color, 				# 颜色
    edgecolor, 			# 边缘颜色
    normed=True, 		# 是否以密度方式显示
)
```

案例：绘制统计直方图显示图片像素亮度分布：

```python
import numpy as np
import matplotlib.pyplot as mp
import scipy.misc as sm

img = sm.imread('../data/forest.jpg', True)
print(img.shape)

pixes = img.ravel()
mp.figure('Image Hist', facecolor='lightgray')
mp.title('Image Hist', fontsize=18)
mp.xticks(np.linspace(0, 255, 11))
mp.hist(x=pixes, bins=10, color='dodgerblue', range=(0, 255), edgecolor='white', normed=False)
mp.show()
```

#### 7）饼图

执行结果：

![](images/%E9%A5%BC%E5%9B%BE%E7%A4%BA%E4%BE%8B.png)

绘制饼状图的基本API：

```python
mp.pie(
    values, 		# 值列表		
    spaces, 		# 扇形之间的间距列表
    labels, 		# 标签列表
    colors, 		# 颜色列表
    '%d%%',			# 标签所占比例格式
	shadow=True, 	# 是否显示阴影
    startangle=90	# 逆时针绘制饼状图时的起始角度
    radius=1		# 半径
)
```

案例：绘制饼状图显示6门编程语言的流行程度：

```python
import matplotlib.pyplot as mp
import numpy as np

mp.figure('pie', facecolor='lightgray')
mp.title('Pie', fontsize=20)
# 整理数据
values = [15, 13.3, 8.5, 7.3, 4.62, 51.28]
spaces = [0.05, 0.01, 0.01, 0.01, 0.01, 0.01]
labels = ['Java', 'C', 'Python', 'C++', 'VB', 'Other']
colors = ['dodgerblue', 'orangered', 'limegreen', 'violet', 'gold','blue']
# 等轴比例
mp.axis('equal')
mp.pie(
    values,  # 值列表
    spaces,  # 扇形之间的间距列表
    labels,  # 标签列表
    colors,  # 颜色列表
    '%d%%',  # 标签所占比例格式
    shadow=True,  # 是否显示阴影
    startangle=90,  # 逆时针绘制饼状图时的起始角度
    radius=1  # 半径
)
mp.legend()
mp.show()
```

#### 8）等高线图

执行结果：

![](images/%E7%AD%89%E9%AB%98%E7%BA%BF%E7%A4%BA%E4%BE%8B.png)

##### ① API介绍

组成等高线需要网格点坐标矩阵，也需要每个点的高度。所以等高线属于3D数学模型范畴。

绘制等高线的相关API：

```python
mp.contourf(x, y, z, 8, cmap='jet')
cntr = mp.contour(
    x, 					# 网格坐标矩阵的x坐标 （2维数组）
    y, 					# 网格坐标矩阵的y坐标 （2维数组）
    z, 					# 网格坐标矩阵的z坐标 （2维数组）
    8, 					# 把等高线绘制成8部分
    colors='black',		# 等高线的颜色
	linewidths=0.5		# 线宽
)
```

##### ② 坐标矩阵

![](images/contour.png)

![](images/网格点1.png)

将上面的点使用矩阵表示为：
$$
X = 
\left[
\begin{matrix}
0 & 1 & 2 \\
0 & 1 & 2 \\
\end{matrix} \right]\tag{2}\\
$$

$$
Y = 
\left[
\begin{matrix}
1 & 1 & 1 \\
0 & 0 & 0 \\
\end{matrix} \right]\tag{2}
$$

这就是坐标矩阵。

##### ③ 案例

生成网格坐标矩阵，并且绘制等高线：

```python
import matplotlib.pyplot as mp
import numpy as np

n = 1000
# 生成网格化坐标矩阵
x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))

# 根据每个网格点坐标，通过某个公式计算z高度坐标
z = (1 - x / 2 + x ** 5 + y ** 3) * np.exp(-x ** 2 - y ** 2)

mp.figure('Contour', facecolor='lightgray')
mp.title('Contour', fontsize=20)
mp.xlabel('x', fontsize=14)
mp.ylabel('y', fontsize=14)
mp.tick_params(labelsize=10)
mp.grid(linestyle=':')

# 绘制等高线图
mp.contourf(x, y, z, 12, cmap='jet') #创建三维等高线图
cntr = mp.contour(x, y, z, 12, colors='black', linewidths=0.5) #绘制

# 为等高线图添加高度标签
mp.clabel(cntr, inline_spacing=1, fmt='%.1f', fontsize=10)
mp.show()
```

#### 9）热图

执行结果：

![](images/热成像图.png)

原理：用图形的方式显示矩阵及矩阵中值的大小。

绘制热成像图的相关API：

```python
# 把矩阵z图形化，使用cmap表示矩阵中每个元素值的大小
# origin: 坐标轴方向
#    upper: 缺省值，原点在左上角
#    lower: 原点在左下角
mp.imshow(z, cmap='jet', origin='lower')
```

使用颜色条显示热度值：

```python
mp.colorbar()
```

示例：绘制热成像图

```python
# 热成像图示例
import numpy as np
import matplotlib.pyplot as mp
import scipy.misc as sm

# 生成数据
img = sm.imread('../data/lily.jpg', True)

mp.figure('ColorBar', facecolor='lightgray') #ColorBar:热成像图
mp.title('ColorBar')
mp.imshow(img, cmap='jet')
mp.colorbar() #显示边条
mp.show()
```

#### 10）3D图像绘制

##### ① API介绍

 matplotlib支持绘制三维曲面。若希望绘制三维曲面，需要使用axes3d提供的3d坐标系。

```python
from mpl_toolkits.mplot3d import axes3d
ax3d = mp.gca(projection='3d')   # class axes3d
```

matplotlib支持绘制三维点阵、三维曲面、三维线框图：

```python
ax3d.scatter(..)		# 绘制三维点阵
ax3d.plot_surface(..)	# 绘制三维曲面
ax3d.plot_wireframe(..)	# 绘制三维线框图
```

##### ② 案例

**3D散点图：**

执行结果：

![](C:/Users/xuming/Desktop/20.02%E7%A0%94%E5%8F%91/%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%99/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/images/3D%E6%95%A3%E7%82%B9%E5%9B%BE.png)

3d散点图的绘制相关API：

```python
ax3d.scatter(
    xs, 			# x轴坐标数组
    ys,				# y轴坐标数组
    zs=0,			# z轴坐标数组
    marker='', 		# 点型
    s=10,			# 大小
    zorder='',		# 图层序号
    color='',		# 颜色
    edgecolor='', 	# 边缘颜色
    facecolor='',	# 填充色
    c=v,			# 颜色值 根据cmap映射应用相应颜色
    cmap=''			# 
)
```

随机生成3组坐标，程标准正态分布规则，并且绘制它们。

```python
# 绘制3D图
import numpy as np
import matplotlib.pyplot as mp
from mpl_toolkits.mplot3d import Axes3D

# 产生数据
n = 100
x = np.random.normal(0, 1, n)
y = np.random.normal(0, 1, n)
z = np.random.normal(0, 1, n)

d = np.sqrt(x ** 2 + y ** 2 + z ** 2) #计算颜色
mp.figure('3D Scatter')
ax = mp.gca(projection='3d')  # 创建三维坐标系
mp.title('3D Scatter', fontsize=20)
ax.set_xlabel('x', fontsize=14)
ax.set_ylabel('y', fontsize=14)
ax.set_zlabel('z', fontsize=14)
mp.tick_params(labelsize=10)

ax.scatter(x, y, z,
           s=80, #大小
           c=d, #颜色
           cmap='jet_r', #色彩反向映射
           alpha=0.5)
mp.show()
```

**3D曲面图**

执行结果：

![](images/3D%E5%B9%B3%E9%9D%A2%E5%9B%BE.png)



3d平面图的绘制相关API：

```python
ax3d.plot_surface(
    x, 					# 网格坐标矩阵的x坐标 （2维数组）
    y, 					# 网格坐标矩阵的y坐标 （2维数组）
    z, 					# 网格坐标矩阵的z坐标 （2维数组）
    rstride=30,			# 行跨距
    cstride=30, 		# 列跨距
    cmap='jet'			# 颜色映射
)
```

案例：绘制3d曲面图

```python
# 绘制3D曲面图
import numpy as np
import matplotlib.pyplot as mp
from mpl_toolkits.mplot3d import Axes3D

n = 1000
# 生成网格化坐标矩阵
x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))
# 根据每个网格点坐标，通过某个公式计算z高度坐标
z = (1 - x / 2 + x ** 5 + y ** 3) * np.exp(-x ** 2 - y ** 2)
mp.figure('3D', facecolor='lightgray')

ax3d = mp.gca(projection='3d')
mp.title('3D Surface', fontsize=18)
ax3d.set_xlabel('x', fontsize=14)
ax3d.set_ylabel('y', fontsize=14)
ax3d.set_zlabel('z', fontsize=14)
mp.tick_params(labelsize=10)
# rstride: 行跨距
# cstride: 列跨距
ax3d.plot_surface(x, y, z, rstride=30, cstride=30, cmap='jet')

mp.show()
```

**3D线框图**

案例：3d线框图的绘制（将案例中的调用plot_surface函数一行换成下面的代码）

```python
# rstride: 行跨距
# cstride: 列跨距 
ax3d.plot_wireframe(x,y,z,rstride=30,cstride=30, 
	linewidth=1, color='dodgerblue')
```

执行结果：

![](images/3D折线图.png)



#### 11）简单动画

动画即是在一段时间内快速连续的重新绘制图像的过程。

matplotlib提供了方法用于处理简单动画的绘制。定义update函数用于即时更新图像。

```python
import matplotlib.animation as ma
#定义更新函数行为
def update(number):
    pass
# 每隔10毫秒执行一次update更新函数，作用于mp.gcf()当前窗口对象
# mp.gcf()：	获取当前窗口
# update：	更新函数
# interval：	间隔时间（单位：毫秒）
anim = ma.FuncAnimation(mp.gcf(), update, interval=10)
mp.show()
```

案例：随机生成各种颜色的100个气泡，让他们不断的增大，直至破裂。

```python
# 绘制动画
import numpy as np
import matplotlib.pyplot as mp
import matplotlib.animation as ma

# 随机生成100个点对象
# random.uniform: 产生均匀分布
n = 100
balls_position = np.random.uniform(0, 1, (n, 2))  # 产生均匀的位置
balls_size = np.random.uniform(40, 70, n)  # 生成大小，大小在40到70之间
balls_growth = np.random.uniform(10, 20, n)  # 增长值，10到20之间
balls_color = np.random.uniform(0, 1, (n, 4))  # 生成颜色，范围0~1之间  R,G,B,alpha
# print(balls_color)

mp.figure("Animation", facecolor='lightgray')
mp.title("Animation", fontsize=14)
mp.xticks([])
mp.yticks([])

# 画散点图
sc = mp.scatter(
    balls_position[:, 0],  # 获取所有气泡的x坐标
    balls_position[:, 1],  # 获取所有气泡的y坐标
    balls_size,  # 获取所有气泡的大小
    color=balls_color,  # 获取所有气泡的颜色
    alpha=0.5)

# 定义更新函数行为
# number：每次调用update会产生一个值传入
def update(number):
    global balls_size, balls_position
    # print("number:", number)
    balls_size += balls_growth  # 增加气泡大小
    # 每次让一个气泡破裂，随机生成一个新的
    boom_ind = number % n
    balls_size[boom_ind] = 0
    balls_position[boom_ind] = np.random.uniform(0, 1, (1, 2))#随机生成一个气泡
    # 重新设置属性
    sc.set_sizes(balls_size)
    sc.set_offsets(balls_position)

# 每隔30毫秒执行一次update更新函数，作用于mp.gcf()当前窗口对象
# mp.gcf()：	获取当前窗口
# update：		更新函数
# interval：	间隔时间（单位：毫秒）
anim = ma.FuncAnimation(mp.gcf(), update, interval=30)
mp.show()
```

执行结果：

![](images/动画示例.png)



## 五、统计学常用指标

### 1. 加载文件

#### 1）API介绍

numpy提供了函数用于加载逻辑上可被解释为二维数组的文本文件，格式如下：

```
数据项1 <分隔符> 数据项2 <分隔符> ... <分隔符> 数据项n
例如：
AA,AA,AA,AA,AA
BB,BB,BB,BB,BB
...
或：
AA:AA:AA:AA:AA
BB:BB:BB:BB:BB
...

```

调用numpy.loadtxt()函数可以直接读取该文件并且获取ndarray数组对象：

```python
import numpy as np
# 直接读取该文件并且获取ndarray数组对象 
# 返回值：
#     unpack=False：返回一个二维数组
#     unpack=True： 多个一维数组
np.loadtxt(
    '../aapl.csv',			# 文件路径
    delimiter=',',			# 分隔符
    usecols=(1, 3),			# 读取1、3两列 （下标从0开始）
    unpack=False,			# 是否按列拆包，是否单独拆分变量返回
    dtype='U10, f8',		# 制定返回每一列数组中元素的类型
    converters={1:func}		# 转换器函数字典
)    

```

#### 2）案例：绘制股票K线图

第一步：读取aapl.csv文件，得到文件中的信息：

```python
# 读取文本文件示例
import numpy as np
import datetime as dt


# 日期格式转换函数: 将日月年转换为年月日格式
def dmy2ymd(dmy):
    dmy = str(dmy, encoding="utf-8")
    # 从指定字符串返回一个日期时间对象
    dat = dt.datetime.strptime(dmy, "%d-%m-%Y").date()
    tm = dat.strftime("%Y-%m-%d")  # 格式化
    return tm

dates, open_prices, highest_prices, lowest_prices, close_prices = \
    np.loadtxt("../da_data/aapl.csv", #文件路径
               delimiter=",", #指定分隔符
               usecols=(1,3,4,5,6), #读取的列(下标从0开始)
               unpack=True, #拆分数据
               dtype="M8[D], f8, f8, f8, f8", #指定每一列的类型
               converters={1:dmy2ymd}) #
print(dates)
print(open_prices)
print(highest_prices)
print(lowest_prices)
print(close_prices)
```

第二步：绘制价格折线图

```python
#### 2.绘制图像
import matplotlib.pyplot as mp
import matplotlib.dates as md

# 绘制k线图，x轴为日期
mp.figure("APPL K-Line", facecolor="lightgray")
mp.title("APPL K-Line")
mp.xlabel("Day", fontsize=12)
mp.ylabel("Price", fontsize=12)

# 获取坐标轴
ax = mp.gca()
# 设置主刻度定位器为周定位器(每周一显示刻度文本)
ax.xaxis.set_major_locator(md.WeekdayLocator(byweekday=md.MO))
ax.xaxis.set_major_formatter(md.DateFormatter("%d %b %Y"))  # %b表示月份简写
# 设置次刻度定位器为天定位器
ax.xaxis.set_minor_locator(md.DayLocator())
mp.tick_params(labelsize=8)
dates = dates.astype(md.datetime.datetime)

mp.plot(dates, open_prices, color="dodgerblue", linestyle="--")
mp.gcf().autofmt_xdate()  # 旋转、共享日期显示

mp.show()
```

执行结果：

![](images/K-line.png)

第三步：绘制每一天的蜡烛图（在mp.show()之前加入以下代码）：

```python
#### 3.绘制蜡烛图
rise = close_prices >= open_prices  # rise为布尔类型构成列表
color = np.array([("red" if x else "green") for x in rise])
color[rise] = "white"
# 边框颜色
edge_color = ["red" if x else "green" for x in rise]

# 绘制线条
mp.bar(dates,  # x轴
       highest_prices - lowest_prices,  # 区间：最高价-最低价
       0.1,  # 宽度
       lowest_prices,  # 底部坐标
       color=edge_color)
# 绘制方块
mp.bar(dates,  # x轴
       close_prices - open_prices,  # 区间：收盘价-开盘价
       0.8,  # 宽度
       open_prices,  # 底部坐标
       color=color, # 颜色
       edgecolor=edge_color, #边框颜色
       zorder=3)
```

执行结果：

![](images/蜡烛图.png)

### 2. 算数平均值

```
S = [s1, s2, ..., sn]
```

样本中的每个值都是真值与误差的和。

```python
算数平均值：
m = (s1 + s2 + ... + sn) / n
```

算数平均值表示对真值的无偏估计。

```python
m = np.mean(array)
m = array.mean()
```

案例：计算收盘价的算术平均值。在上一个绘制K线图示例mp.show()之前添加如下代码：

```python
#### 求股票价格算数平均值，并绘制线条
mean = np.mean(close_prices)
mp.hlines(mean, dates[0], dates[-1], color="blue", linestyles=":")
```

执行结果：

![](images/蜡烛图-均线图.png)

### 3. 加权平均值

求平均值时，考虑不同样本的重要性，赋予不同的权重。

样本：$S = [s_1, s_2, s_3 ... s_n]$

权重：$W =[w_1, w_2, w_3 ... w_n]$

加权平均值：
$$
a = \frac{s_1w_1 + s_2w_2 + ... + s_nw_n}{w_1+w_2+...+w_n}
$$

```python
a = np.average(closing_prices, weights=volumes)
```



VWAP - 成交量加权平均价格（成交量体现了市场对当前交易价格的认可度，成交量加权平均价格将会更接近这支股票的真实价值）

```python
# 读取文本文件示例
# 绘制K线
# 求算数平均值并绘制均值曲线
import numpy as np
import datetime as dt


#### 1.读取数据
# 日期格式转换函数: 将日月年转换为年月日格式
def dmy2ymd(dmy):
    dmy = str(dmy, encoding="utf-8")
    # 从指定字符串返回一个日期时间对象
    dat = dt.datetime.strptime(dmy, "%d-%m-%Y").date()  # 字符串转日期
    tm = dat.strftime("%Y-%m-%d")  # 日期转字符串
    return tm


dates, open_prices, highest_prices, lowest_prices, close_prices, volumns = \
    np.loadtxt("../da_data/aapl.csv",  # 文件路径
               delimiter=",",  # 指定分隔符
               usecols=(1, 3, 4, 5, 6, 7),  # 读取的列(下标从0开始)
               unpack=True,  # 拆分数据
               dtype="M8[D], f8, f8, f8, f8, f8",  # 指定每一列的类型
               converters={1: dmy2ymd})  #
print(dates)
print(open_prices)
print(highest_prices)
print(lowest_prices)
print(close_prices)

#### 2.绘制图像
import matplotlib.pyplot as mp
import matplotlib.dates as md

# 绘制k线图，x轴为日期
mp.figure("APPL K-Line", facecolor="lightgray")
mp.title("APPL K-Line")
mp.xlabel("Day", fontsize=12)
mp.ylabel("Price", fontsize=12)

# 获取坐标轴
ax = mp.gca()
# 设置主刻度定位器为周定位器(每周一显示刻度文本)
ax.xaxis.set_major_locator(md.WeekdayLocator(byweekday=md.MO))
ax.xaxis.set_major_formatter(md.DateFormatter("%d %b %Y"))  # %b表示月份简写
# 设置次刻度定位器为天定位器
ax.xaxis.set_minor_locator(md.DayLocator())
mp.tick_params(labelsize=8)
dates = dates.astype(md.datetime.datetime)

mp.plot(dates, open_prices, color="dodgerblue", linestyle="--")
mp.gcf().autofmt_xdate()  # 旋转、共享日期显示

#### 3.绘制蜡烛图
rise = close_prices >= open_prices  # rise为布尔类型构成列表
color = np.array([("red" if x else "green") for x in rise])
color[rise] = "white"
# 边框颜色
edge_color = ["red" if x else "green" for x in rise]

# 绘制线条
mp.bar(dates,  # x轴
       highest_prices - lowest_prices,  # 区间：最高价-最低价
       0.1,  # 宽度
       lowest_prices,  # 底部坐标
       color=edge_color)
# 绘制方块
mp.bar(dates,  # x轴
       close_prices - open_prices,  # 区间：收盘价-开盘价
       0.8,  # 宽度
       open_prices,  # 底部坐标
       color=color, # 颜色
       edgecolor=edge_color, #边框颜色
       zorder=3)

#### 4. 求股票价格算数平均值，并绘制线条
mean = np.mean(close_prices)
mp.hlines(mean, dates[0], dates[-1], color="blue", linestyles=":")

# VWAP
vwap = np.average(close_prices, weights=volumns)
mp.hlines(vwap, dates[0], dates[-1], color="orangered", linestyles="--")

mp.show()
```

执行结果（蓝色水平虚线部分）：

![](images/蜡烛图-加权平均.png)



### 4. 最值

**np.max() / np.min() / np.ptp()：** 返回一个数组中最大值/最小值/极差（最大值减最小值）

```python
import numpy as np
# 产生9个介于[10, 100)区间的随机数
a = np.random.randint(10, 100, 9)
print(a)
print(np.max(a), np.min(a), np.ptp(a))
```

**np.argmax() np.argmin()：** 返回一个数组中最大/最小元素的下标

```python
print(np.argmax(a), np.argmin(a))
```

**np.maximum() np.minimum()：** 将两个同维数组中对应元素中最大/最小元素构成一个新的数组

```python
print(np.maximum(a, b), np.minimum(a, b), sep='\n')
```

案例：评估AAPL股票的波动性，找出最高价、最低价格发生的日期。

```python
# 最值计算示例
import numpy as np
import datetime as dt

#### 1.读取数据
# 日期格式转换函数: 将日月年转换为年月日格式
def dmy2ymd(dmy):
    dmy = str(dmy, encoding="utf-8")
    # 从指定字符串返回一个日期时间对象
    dat = dt.datetime.strptime(dmy, "%d-%m-%Y").date()  # 字符串转日期
    tm = dat.strftime("%Y-%m-%d")  # 日期转字符串
    return tm


dates, open_prices, highest_prices, lowest_prices, close_prices, volumns = \
    np.loadtxt("../da_data/aapl.csv",  # 文件路径
               delimiter=",",  # 指定分隔符
               usecols=(1, 3, 4, 5, 6, 7),  # 读取的列(下标从0开始)
               unpack=True,  # 拆分数据
               dtype="M8[D], f8, f8, f8, f8, f8",  # 指定每一列的类型
               converters={1: dmy2ymd})  #
# 评估波动性
min_val = np.min(lowest_prices)  # 最低值
max_val = np.max(highest_prices)  # 最大值
print(min_val, "~", max_val)

# 获取最高价、最低价的日期
min_date = np.argmin(lowest_prices)
max_date = np.argmax(highest_prices)
print(dates[min_date], ":", lowest_prices[min_date])  # 最低价发生日期及价格
print(dates[max_date], ":", highest_prices[max_date])  # 最高价发生日期及价格

# 波动范围
lowest_ptp = np.ptp(lowest_prices) #最低价波动范围
highest_ptp = np.ptp(highest_prices) #最高价波动范围
print("lowest_ptp:", lowest_ptp)
print("highest_ptp:", highest_ptp)
```

执行结果：

```
333.53 ~ 364.9
2011-01-28 : 333.53
2011-02-16 : 364.9
lowest_ptp: 26.970000000000027
highest_ptp: 24.859999999999957
```



### 5. 中位数

将多个样本按照大小排序，取中间位置的元素。

**若样本数量为奇数，中位数为最中间的元素**

$[1, 2000, 3000, 4000, 10000000]$

**若样本数量为偶数，中位数为最中间的两个元素的平均值**

$[1,2000,3000,4000,5000,10000000]$

案例：分析中位数的算法，测试numpy提供的中位数API：

```python
import numpy as np
closing_prices = np.loadtxt( '../../data/aapl.csv', 
	delimiter=',', usecols=(6), unpack=True)
size = closing_prices.size
sorted_prices = np.msort(closing_prices)
median = (sorted_prices[int((size - 1) / 2)] + sorted_prices[int(size / 2)]) / 2
print(median)
median = np.median(closing_prices)
print(median)
```



### 6. 标准差

样本（sample）：
$$
S = [s_1, s_2, s_3, ..., s_n]
$$


平均值：
$$
m = \frac{s_1 + s_2 + s_3 + ... + s_n}{n}
$$


离差（deviation）：表示某组数据距离某个中心点的偏离程度
$$
D = [d_1, d_2, d_3, ..., d_n]\\
d_i = S_i-m
$$
离差方：
$$
Q = [q_1, q_2, q_3, ..., q_n]\\
q_i=d_i^2
$$


总体方差（variance）：
$$
v = \frac{(q_1+q_2+q_3 + ... + q_n)}{n}
$$


总体标准差（standard deviation）：
$$
s = \sqrt{v}
$$


样本方差：
$$
v' = \frac{(q_1+q_2+q_3 + ... + q_n)}{n-1}
$$
其中，n-1称之为“贝塞尔校正”，这是因为抽取样本时候，样本主要是落在中心值附近，那么样本方差一定小于总体的方差。为了能弥补这方面的缺陷，那么我们把公式的n改为n-1,以此来提高方差的数值。这种方法叫做贝塞尔校正系数。

样本标准差：
$$
s' = \sqrt{v'}
$$


```python
# 标准差、样本方差示例
import numpy as np

# 读取文件
close_prices = np.loadtxt("../da_data/aapl.csv",
                          delimiter=",",
                          usecols=(6),
                          unpack=True)

mean = np.mean(close_prices)        # 算数平均值
devs = close_prices - mean          # 离差(结果为列表)
dsqs = devs ** 2                    # 离差方
pvar = np.sum(dsqs) / dsqs.size     # 总体方差
pstd = np.sqrt(pvar)                # 总体标准差

svar = np.sum(dsqs) / (dsqs.size - 1)   # 样本方差
sstd = np.sqrt(svar)                    # 样本标准差
print("总体标准差:", pstd, " 样本标准差:", sstd)

# 使用np提供的方法
pstd = np.std(close_prices)             # 总体标准差
sstd = np.std(close_prices, ddof=1)     # 样本标准差
print("总体标准差:", pstd, " 样本标准差:", sstd)
```

执行结果：

```
总体标准差: 7.080008325481608  样本标准差: 7.201042876260849
总体标准差: 7.080008325481608  样本标准差: 7.201042876260849
```



### 7. 数组的轴向汇总

思考：有如下数据，如何按行、按列进行统计

| 姓名  | 语文 | 数学 | 英语 | 科学 |
| ----- | ---- | ---- | ---- | ---- |
| Tom   | 85   | 80   | 90   | 95   |
| Jerry | 90   | 90   | 92   | 94   |
| Lily  | 88   | 83   | 93   | 76   |

numpy提供了如下API进行轴向汇总：

```python
def func(data):
    pass
#func 	处理函数
#axis 	轴向 [0,1]  0-按列  1-按行
#array 	数组
np.apply_along_axis(func, axis, array)
```

示例：生成二维数组，在行、列方向求均值

```python
# 数组轴向汇总
import numpy as np

arr = np.arange(1, 10).reshape(3, 3)
print(arr)

# 汇总算法函数
def func(data):
    # print("func")
    return data.mean()

result = np.apply_along_axis(func, 1, arr)  # 按行求均值
print(result)

result = np.apply_along_axis(func, 0, arr)  # 按列求均值
print(result)
```



案例：汇总每周的最高价，最低价，开盘价，收盘价。沿着数组中所指定的轴向，调用处理函数，并将每次调用的返回值重新组织成数组返回（课后作业）。

```python
wdays, opening_prices, highest_prices, \
    lowest_prices, closing_prices = np.loadtxt(
        '../data/aapl.csv',
        delimiter=',', usecols=(1, 3, 4, 5, 6),
        unpack=True, converters={1: dmy2wday})

first_mon = np.where(wdays==0)[0][0]
last_fri = np.where(wdays==4)[0][-1]

wdays = wdays[first_mon:last_fri+1]
indices = np.arange(first_mon, last_fri+1)

#把周一至周五每天的indices值统计为5个数组
mon_indices = indices[wdays==0]
tue_indices = indices[wdays==1]
wen_indices = indices[wdays==2]
thu_indices = indices[wdays==3]
fri_indices = indices[wdays==4]
max_len = np.max((mon_indices.size, tue_indices.size, wen_indices.size, thu_indices.size, fri_indices.size))
mon_indices = np.pad(mon_indices, pad_width=(0, max_len-mon_indices.size), mode='constant', constant_values=-1)
indices = np.vstack((mon_indices,tue_indices,wen_indices,thu_indices,fri_indices))

# numpy将会把每一行的indices传入summary函数执行业务
def summary(indices):
    indices = indices[indices!=-1]
    opening_price = opening_prices[indices[0]]
    highest_price = highest_prices[indices].max()
    lowest_price = lowest_prices[indices].min()
    closing_price = closing_prices[indices[-1]]
    return opening_price, highest_price, lowest_price, closing_price
	
r = np.apply_along_axis(summary, 1, indices)
print(r)

np.savetxt('../../data/summary.csv', summaries, delimiter=',', fmt='%g')
```



### 8. 协方差、相关系数、相关矩阵

#### 1. 协方差

通过两组统计数据计算而得的协方差可以评估这两组统计数据的相似程度。

**样本**：

```python
A = [a1, a2, ..., an]
B = [b1, b2, ..., bn]
```

**平均值**：

```python
ave_a = (a1 + a2 +...+ an)/n
ave_b = (b1 + b2 +...+ bn)/n
```

**离差**（用样本中的每一个元素减去平均数，求得数据的误差程度）：

```python
dev_a = [a1, a2, ..., an] - ave_a
dev_b = [b1, b2, ..., bn] - ave_b
```

**协方差**

协方差可以简单反映两组统计样本的相关性，值为正，则为正相关；值为负，则为负相关，绝对值越大相关性越强。

```
cov_ab = ave(dev_a * dev_b)
cov_ba = ave(dev_b * dev_a)

```

案例：读取两只股票交易数据，并计算协方差

```python
# 股票协方差示例
import numpy as np
import datetime as dt


#### 1.读取数据
# 日期格式转换函数: 将日月年转换为年月日格式
def dmy2ymd(dmy):
    dmy = str(dmy, encoding="utf-8")
    # 从指定字符串返回一个日期时间对象
    dat = dt.datetime.strptime(dmy, "%d-%m-%Y").date()  # 字符串转日期
    tm = dat.strftime("%Y-%m-%d")  # 日期转字符串
    return tm


dates, bhp_close_prices = np.loadtxt("../da_data/bhp.csv",  # 文件路径
                                     delimiter=",",  # 指定分隔符
                                     usecols=(1, 6),  # 读取的列(下标从0开始)
                                     unpack=True,  # 拆分数据
                                     dtype="M8[D], f8",  # 指定每一列的类型
                                     converters={1: dmy2ymd})  #
dates, vale_close_prices = np.loadtxt("../da_data/vale.csv",  # 文件路径
                                      delimiter=",",  # 指定分隔符
                                      usecols=(1, 6),  # 读取的列(下标从0开始)
                                      unpack=True,  # 拆分数据
                                      dtype="M8[D], f8",  # 指定每一列的类型
                                      converters={1: dmy2ymd})  #

#### 2.绘制图像
import matplotlib.pyplot as mp
import matplotlib.dates as md

# 绘制k线图，x轴为日期
mp.figure("COV", facecolor="lightgray")
mp.title("COV")
mp.xlabel("Date", fontsize=12)
mp.ylabel("Price", fontsize=12)

# 获取坐标轴
ax = mp.gca()
# 设置主刻度定位器为周定位器(每周一显示刻度文本)
ax.xaxis.set_major_locator(md.WeekdayLocator(byweekday=md.MO))
ax.xaxis.set_major_formatter(md.DateFormatter("%d %b %Y"))  # %b表示月份简写
# 设置次刻度定位器为天定位器
ax.xaxis.set_minor_locator(md.DayLocator())
mp.tick_params(labelsize=8)
dates = dates.astype(md.datetime.datetime)

mp.plot(dates, bhp_close_prices, label="BHP")
mp.plot(dates, vale_close_prices, label="VALE")
mp.gcf().autofmt_xdate()  # 旋转、共享日期显示

# 计算两只股票的协方差
## 求均值
avg_bhp = np.mean(bhp_close_prices)
avg_vale = np.mean(vale_close_prices)
## 求离差
dev_bhp = bhp_close_prices - avg_bhp
dev_vale = vale_close_prices - avg_vale
## 求协方差
cov = np.mean(dev_bhp * dev_vale)
print("cov:", cov)

mp.grid(linestyle="--")
mp.legend()
mp.show()
```

执行结果：

控制台输出：

```
cov: 3.135577333333333

```

可视化：

![](C:/Users/xuming/Desktop/20.02%E7%A0%94%E5%8F%91/%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%99/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/images/%E4%B8%A4%E5%8F%AA%E8%82%A1%E7%A5%A8%E5%8D%8F%E6%96%B9%E5%B7%AE.png)



#### 2.相关系数

上一小节，求出两组股票协方差为3.135577333333333，表示两只股票具有正相关性。但究竟相关性有多强？如何度量？这就需要用到相关系数。

协方差除去两组统计样本标准差的乘积是一个[-1, 1]之间的数，该结果称为统计样本的相关系数。

```python
# a组样本 与 b组样本做对照后的相关系数
cov_ab/(std_a * std_b)
# b组样本 与 a组样本做对照后的相关系数
cov_ba/(std_b * std_a)
# a样本与a样本作对照   b样本与b样本做对照   二者必然相等
cov_ab/(std_a * std_b) = cov_ba/(std_b * std_a)
```

通过相关系数可以分析两组数据的相关性：

- 若相关系数越接近于0，越表示两组样本越不相关
- 若相关系数越接近于1，越表示两组样本正相关
- 若相关系数越接近于-1，越表示两组样本负相关



案例：在上一些示例中，加入如下代码，输出案例中两组数据的相关系数：

```python
print('相关系数：', cov_ab/(np.std(a)*np.std(b)), cov_ba/(np.std(a)*np.std(b)))
```



#### 3. 相关矩阵

numpy有没有提供计算相关系数的API呢？这就是计算相关矩阵。
$$
\left[ \begin{array}{c}
\frac{var\_a}{std\_a \times std\_a} & \frac{cov\_ab}{std\_a \times std\_b} \\
\frac{cov\_ba}{std\_b \times std\_a} & \frac{var\_b}{std\_b \times std\_b}\\
\end{array} 
\right ]
$$
矩阵正对角线上的值都为1。（同组样本自己相比绝对正相关）
$$
\left[ \begin{array}{ccc}
1 & \frac{cov\_ab}{std\_a \times std\_b} \\
\frac{cov\_ba}{std\_b \times std\_a} & 1\\
\end{array} 
\right ]
$$
numpy提供了求得相关矩阵的API：

```python
# 相关矩阵
# 返回值为一个矩阵：[[a方差，ab协方差], [ba协方差, b方差]]
numpy.corrcoef(a, b)	
```

在上一小节示例中加入如下代码：

```python
cm = np.corrcoef(bhp_close_prices, vale_close_prices)
print("cm:\n", cm)
```

执行结果：

```
cm:
 [[1.         0.86649883]
 [0.86649883 1.        ]]

```

其中cm[0,1]或cm[1,0]即为相关系数.

## 六、金融领域数据分析示例

### 1. 移动均线

移动均线(Moving Average，简称MA)是用统计分析的方法，将一定时期内的证券价格（指数）加以平均，并把不同时间的平均值连接起来，形成一根MA，用以观察证券价格变动趋势的一种技术指标。移动平均线是由著名的美国投资专家Joseph E.Granville（葛兰碧，又译为格兰威尔）于20世纪中期提出来的。均线理论是当今应用最普遍的技术指标之一，它帮助交易者确认现有趋势、判断将出现的趋势、发现过度延生即将反转的趋势。

移动均线常用线有5天、10天、30天、60天、120天和240天的指标。其中，5天和10天的短期移动平均线，是短线操作的参照指标，称做日均线指标；30天和60天的是中期均线指标，称做季均线指标；120天、240天的是长期均线指标，称做年均线指标。

收盘价5日均线：从第五天开始，每天计算最近五天的收盘价的平均值所构成的一条线。

移动均线算法：

```python
(a+b+c+d+e)/5
(b+c+d+e+f)/5
(c+d+e+f+g)/5
...
(f+g+h+i+j)/5
```

在K线图中绘制5日均线图

```python
# 移动均线示例
import numpy as np
import datetime as dt


#### 1.读取数据
# 日期格式转换函数: 将日月年转换为年月日格式
def dmy2ymd(dmy):
    dmy = str(dmy, encoding="utf-8")
    # 从指定字符串返回一个日期时间对象
    dat = dt.datetime.strptime(dmy, "%d-%m-%Y").date()  # 字符串转日期
    tm = dat.strftime("%Y-%m-%d")  # 日期转字符串
    return tm


dates, open_prices, highest_prices, lowest_prices, close_prices = \
    np.loadtxt("../da_data/aapl.csv",  # 文件路径
               delimiter=",",  # 指定分隔符
               usecols=(1, 3, 4, 5, 6),  # 读取的列(下标从0开始)
               unpack=True,  # 拆分数据
               dtype="M8[D], f8, f8, f8, f8",  # 指定每一列的类型
               converters={1: dmy2ymd})  #

#### 2.绘制图像
import matplotlib.pyplot as mp
import matplotlib.dates as md

# 绘制k线图，x轴为日期
mp.figure("APPL K-Line", facecolor="lightgray")
mp.title("APPL K-Line")
mp.xlabel("Day", fontsize=12)
mp.ylabel("Price", fontsize=12)

# 获取坐标轴
ax = mp.gca()
# 设置主刻度定位器为周定位器(每周一显示刻度文本)
ax.xaxis.set_major_locator(md.WeekdayLocator(byweekday=md.MO))
ax.xaxis.set_major_formatter(md.DateFormatter("%d %b %Y"))  # %b表示月份简写
# 设置次刻度定位器为天定位器
ax.xaxis.set_minor_locator(md.DayLocator())
mp.tick_params(labelsize=8)
dates = dates.astype(md.datetime.datetime)

mp.plot(dates, open_prices, color="dodgerblue", linestyle="--")
mp.gcf().autofmt_xdate()  # 旋转、共享日期显示

# 绘制5日均值线
ma_5 = np.zeros(close_prices.size - 4)  # 均值数组
for i in range(ma_5.size):
    ma_5[i] = close_prices[i: i + 5].mean()  # 切片，求均值，并存入均值数组

mp.plot(dates[4:],  # 从第五天开始绘制
        ma_5,  # 数据
        color="orangered",
        label="MA_5")

mp.legend()
mp.show()
```

执行结果：

![](images/5日均线图.png)



### 2. 卷积

#### 1）卷积计算过程

先理解卷积运算的过程：

```python
a = [1, 2, 3, 4, 5]
b = [8, 7, 6]
```

卷积运算API：

```python
# 卷积函数
# a: 数据
# b: 卷积核
# mode: 卷积类型（full, same, valid）
#       full：每个元素参与卷积运算的结果
#       same：结果维度等于max(a,b)
#       valid：两个数组完全重合部分计算的结果
c = numpy.convolve(a, b, mode="full")
```

#### 2）示例

实现简单卷积运算

```python
# 卷积示例
import numpy as np

a = np.array([1, 2, 3, 4, 5])
b = np.array([8, 7, 6])

full_conv = np.convolve(a, b, "full")  # 完全卷积
print("full:", full_conv)

same_conv = np.convolve(a, b, "same")  # 同维卷积
print("same:", same_conv)

valid_conv = np.convolve(a, b, "valid")  # 有效卷积
print("valid:", valid_conv)
```

执行结果：

```
full: [ 8 23 44 65 86 59 30]
same: [23 44 65 86 59]
valid: [44 65 86]
```

#### 3）案例

利用卷积运算实现5日移动均线（用以下代码替换移动均线计算部分）

```python
# 利用卷积实现5日均值线
ma_conv_5 = np.convolve(close_prices, np.ones(5) / 5, "valid")
mp.plot(dates[4:],  # 从第五天开始绘制
        ma_conv_5,  # 数据
        color="orangered",
        label="MA_5")
```

执行结果：

![](images/卷积实现5日移动均线.png)



### 3. 布林带

#### 1）什么是布林带

![](images/布林带.png)

布林带（Bollinger Band）是美国股市分析家约翰·布林根据统计学中的标准差原理设计出来的一种非常实用的技术指标，它由三条线组成：

中轨：移动平均线（图中白色线条）

上轨：中轨+2x5日收盘价标准差	（图中黄色线条，顶部的压力）

下轨：中轨-2x5日收盘价标准差 	（图中紫色线条，底部的支撑力）

布林带收窄代表稳定的趋势，布林带张开代表有较大的波动空间的趋势。

#### 2）布林带的业务指标与含义

利用股价与布林带上轨线、下轨线进行比较，以及结合变化趋势，判断股票买入、卖出的时机。

(1)股价由下向上穿越下轨线（Down）时，可视为买进信号。
(2)股价由下向上穿越中轨时，股价将加速上扬，是加仓买进的信号。
(3)股价在中轨与上轨(UPER）之间波动运行时为多头市场，可持股观望。
(4)股价长时间在中轨与上轨（UPER）间运行后，由上向下跌破中轨为卖出信号。
(5)股价在中轨与下轨（Down）之间向下波动运行时为空头市场，此时投资者应持币观望。
(6)布林中轨经长期大幅下跌后转平，出现向上的拐点，且股价在2～3日内均在中轨之上。此时，若股价回调，其回档低点往往是适量低吸的中短线切入点。
(7)对于在布林中轨与上轨之间运作的强势股，不妨以回抽中轨作为低吸买点，并以中轨作为其重要的止盈、止损线。
(8)飚升股往往股价会短期冲出布林线上轨运行，一旦冲出上轨过多，而成交量又无法持续放出，注意短线高抛了结，如果由上轨外回落跌破上轨，此时也是一个卖点。

#### 3）绘制布林带

以下是一个绘制布林带的示例。

```python
# 布林带示例
import numpy as np
import datetime as dt

#### 1.读取数据
# 日期格式转换函数: 将日月年转换为年月日格式
def dmy2ymd(dmy):
    dmy = str(dmy, encoding="utf-8")
    # 从指定字符串返回一个日期时间对象
    dat = dt.datetime.strptime(dmy, "%d-%m-%Y").date()  # 字符串转日期
    tm = dat.strftime("%Y-%m-%d")  # 日期转字符串
    return tm

dates, open_prices, highest_prices, lowest_prices, close_prices = \
    np.loadtxt("../da_data/aapl.csv",  # 文件路径
               delimiter=",",  # 指定分隔符
               usecols=(1, 3, 4, 5, 6),  # 读取的列(下标从0开始)
               unpack=True,  # 拆分数据
               dtype="M8[D], f8, f8, f8, f8",  # 指定每一列的类型
               converters={1: dmy2ymd})  #

#### 2.绘制图像
import matplotlib.pyplot as mp
import matplotlib.dates as md

# 绘制k线图，x轴为日期
mp.figure("APPL K-Line", facecolor="lightgray")
mp.title("APPL K-Line")
mp.xlabel("Day", fontsize=12)
mp.ylabel("Price", fontsize=12)

# 获取坐标轴
ax = mp.gca()
# 设置主刻度定位器为周定位器(每周一显示刻度文本)
ax.xaxis.set_major_locator(md.WeekdayLocator(byweekday=md.MO))
ax.xaxis.set_major_formatter(md.DateFormatter("%d %b %Y"))  # %b表示月份简写
# 设置次刻度定位器为天定位器
ax.xaxis.set_minor_locator(md.DayLocator())
mp.tick_params(labelsize=8)
dates = dates.astype(md.datetime.datetime)

mp.plot(dates, open_prices, color="dodgerblue", linestyle="--")
mp.gcf().autofmt_xdate()  # 旋转、共享日期显示

# 绘制5日均值线
ma_5 = np.zeros(close_prices.size - 4)  # 均值数组
for i in range(ma_5.size):
    ma_5[i] = close_prices[i: i + 5].mean()  # 切片，求均值，并存入均值数组

mp.plot(dates[4:],  # 从第五天开始绘制
        ma_5,  # 数据
        color="orangered",
        label="MA_5")

# 计算上轨、下轨线
stds = np.zeros(ma_5.size)
for i in range(stds.size):
    stds[i] = close_prices[i: i + 5].std()  # 计算标准差
upper = ma_5 + 2 * stds  # 计算上轨
lower = ma_5 - 2 * stds  # 计算下轨
# 绘制线
mp.plot(dates[4:], upper, color="green", label="UPPER")
mp.plot(dates[4:], lower, color="blue", label="LOWER")
# 填充布林带
mp.fill_between(dates[4:], upper, lower, lower < upper, color="orangered", alpha=0.05)

mp.grid(linestyle="--")
mp.legend()
mp.show()
```

执行结果：

![](images/布林带2.png)



## 七、量化分析数学建模

### 1. 线性模型

如下直线方程属于线性方程：
$$
y = kx + b
$$
图像可表示为：

![](images/标准线性模型.png)

在实际应用，输入和输出可以用线性模型进行拟合，称之为线性模型或线性问题（如房屋面积与总价、成年人的身高与体重）。表示成图像如下图所示：

![](images/实际应用中的线性图.png)



#### 1. 线性预测

假设一组数据符合一种线型规律，那么就可以预测未来将会出现的数据。

```python
a	b	c	d	e	f	?
```

$$
\begin{cases}
aw_0 + bw_1 + cw_2 = d \\
bw_0 + cw_1 + dw_2 = e \\
cw_0 + dw_1 + ew_2 = f \\
\end{cases}
$$

线型方程组转换为矩阵相乘的形式：
$$
\left[ \begin{array}{ccc}
a & b & c\\
b & c & d\\
c & d & e\\
\end{array} 
\right ]
\times
\left[ \begin{array}{ccc}
w_0\\
w_1\\
w_2\\
\end{array} 
\right ]=
\left[ 
\begin{array}{ccc}
d\\
e\\
f\\
\end{array} 
\right ]
\\
\quad \quad  A \quad \quad \quad \quad \quad   x\quad \quad \quad  B  \quad
$$

**矩阵乘法规则**

![](images/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png)



线性预测即是使用线性模型对一组历史数据进行数学表达，求出线性关系系数$w_0, w_1, w_2$，从而使用这个线性模型进行预测的过程。

**线性预测需要使用历史数据进行检验，让预测结果可信度更高**

案例：使用线性预测，预测下一天的收盘价。

```python
# 整理五元一次方程组    最终获取一组股票走势预测值
N = 5
pred_prices = np.zeros(closing_prices.size - 2 * N + 1)
for i in range(pred_prices.size):
    a = np.zeros((N, N))
    for j in range(N):
        a[j, ] = closing_prices[i + j:i + j + N]
    b = closing_prices[i + N:i + N * 2]
    x = np.linalg.lstsq(a, b)[0]
    pred_prices[i] = b.dot(x)
# 由于预测的是下一天的收盘价，所以想日期数组中追加一个元素，为下一个工作日的日期
dates = dates.astype(md.datetime.datetime)
mp.plot(dates, closing_prices, 'o-', c='lightgray', label='Closing Price')
dates = np.append(dates, dates[-1] + pd.tseries.offsets.BDay())
mp.plot(dates[2 * N:], pred_prices, 'o-',c='orangered', 
        linewidth=3,label='Predicted Price')
mp.legend()
mp.gcf().autofmt_xdate() 
mp.show()
```

#### 2. 线性拟合

线性拟合就是试图找到一个最优的线性方程，可以最好的匹配当前样本（到所有样本的距离之和最短，误差最小）。若已知样本只有一个自变量$x$与一个因变量$y$，则线性方程可表示为：
$$
y = kx + b
$$
线性拟合就是根据一组x, y的值，来寻求最佳k,b的值。

有一组散点描述时间序列下的股价：

```python
[x1, y1]
[x2, y2]
[x3, y3] 
...
[xn, yn]
```

我们希望所有点都可以被线性方程$y=kx + b$表示，姑且把所有样本带入方程可得：

```python
kx1 + b = y1
kx2 + b = y2
kx3 + b = y3
...
kxn + b = yn
```

这一组方程表示为矩阵相乘格式：
$$
\left[ \begin{array}{ccc}
x{_1} & 1\\
x{_2} & 1\\
x{_3} & 1 \\
x{_n} & 1 \\
\end{array} 
\right ]
\times
\left[ \begin{array}{ccc}
k\\
b\\
\end{array} 
\right ]
=
\left[ \begin{array}{ccc}
y{_1}\\
y{_2}\\
y{_3}\\
y{_n}\\
\end{array} 
\right ]
$$
样本过多，每两组方程即可求得一组k与b的值。$np.linalg.lstsq(a, b) $可以通过最小二乘法求出所有结果中拟合误差最小的k与b的值。

案例：利用线型拟合画出股价的趋势线

![](C:/Users/xuming/Desktop/20.02%E7%A0%94%E5%8F%91/%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%99/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/images/%E7%BA%BF%E6%80%A7%E6%8B%9F%E5%90%88.png)

1. 绘制趋势线（趋势可以表示为最高价、最低价、收盘价的均值）：

```python
# 线性拟合示例
import numpy as np
import datetime as dt


#### 1.读取数据
# 日期格式转换函数: 将日月年转换为年月日格式
def dmy2ymd(dmy):
    dmy = str(dmy, encoding="utf-8")
    # 从指定字符串返回一个日期时间对象
    dat = dt.datetime.strptime(dmy, "%d-%m-%Y").date()  # 字符串转日期
    tm = dat.strftime("%Y-%m-%d")  # 日期转字符串
    return tm


dates, open_prices, highest_prices, lowest_prices, close_prices = \
    np.loadtxt("../da_data/appl.csv",  # 文件路径
               delimiter=",",  # 指定分隔符
               usecols=(1, 3, 4, 5, 6),  # 读取的列(下标从0开始)
               unpack=True,  # 拆分数据
               dtype="M8[D], f8, f8, f8, f8",  # 指定每一列的类型
               converters={1: dmy2ymd})  #

#### 2.绘制图像
import matplotlib.pyplot as mp
import matplotlib.dates as md

# 绘制k线图，x轴为日期
mp.figure("APPL K-Line", facecolor="lightgray")
mp.title("APPL K-Line")
mp.xlabel("Day", fontsize=12)
mp.ylabel("Price", fontsize=12)

# 获取坐标轴
ax = mp.gca()
# 设置主刻度定位器为周定位器(每周一显示刻度文本)
ax.xaxis.set_major_locator(md.WeekdayLocator(byweekday=md.MO))
ax.xaxis.set_major_formatter(md.DateFormatter("%d %b %Y"))  # %b表示月份简写
# 设置次刻度定位器为天定位器
ax.xaxis.set_minor_locator(md.DayLocator())
mp.tick_params(labelsize=8)
dates = dates.astype(md.datetime.datetime)

mp.plot(dates, open_prices, color="dodgerblue", linestyle="--")
mp.gcf().autofmt_xdate()  # 旋转、共享日期显示

# 求得每天的趋势价格: 最高价、最低价、收盘价求平均值作为趋势价
trend_prices = (highest_prices + lowest_prices + close_prices) / 3
mp.scatter(dates, trend_prices, marker="o",
           color="orangered", s=80, label="Trend Points")

# 绘制趋势线
# A：日期转换为数字
# Y: 趋势价格(trend_prices)
days = dates.astype("M8[D]").astype("int32")
# print(days)
# column_stack: 将1d数组堆叠成2d数组
# ones_like: 返回与给定数组具有相同形状和类型的数组
A = np.column_stack((days, np.ones_like(days)))

# lstsq(least-squares solution):最小二乘法，最小化误差的平方和寻找数据的最佳函数匹配
Y = trend_prices
x = np.linalg.lstsq(A, Y, rcond=None)[0]  # x中包含了k, b的值

trend_line = x[0] * days + x[1]  # y = kx + b
mp.plot(dates, trend_line, color="orangered", label="Trend Line")

if x[0] > 0:
    print("总体趋势上涨")
elif x[0] < 0:
    print("总体趋势下跌")
else:
    print("总体趋势持平")

mp.grid(linestyle="--")
mp.legend()
mp.show()
```

执行结果：

控制台输出：

```
总体趋势上涨
```

**课后作业**

- 绘制顶部压力线（趋势线+(最高价 - 最低价)）

```python
trend_points = (highest_prices + lowest_prices + closing_prices) / 3
spreads = highest_prices - lowest_prices
resistance_points = trend_points + spreads
days = dates.astype(int)
x = np.linalg.lstsq(a, resistance_points)[0]
resistance_line = days * x[0] + x[1]
mp.scatter(dates, resistance_points, c='orangered', alpha=0.5, s=60, zorder=2)
mp.plot(dates, resistance_line, c='orangered', linewidth=3, label='Resistance')
```

- 绘制底部支撑线（趋势线-(最高价 - 最低价)）

```python
trend_points = (highest_prices + lowest_prices + closing_prices) / 3
spreads = highest_prices - lowest_prices
support_points = trend_points - spreads
days = dates.astype(int)
x = np.linalg.lstsq(a, support_points)[0]
support_line = days * x[0] + x[1]
mp.scatter(dates, support_points, c='limegreen', alpha=0.5, s=60, zorder=2)
mp.plot(dates, support_line, c='limegreen', linewidth=3, label='Support')
```



### 2. 多项式模型

在有些数据分布中，使用一条曲线比直线能更好拟合数据，这就需要用到多项式拟合。如下图所示分布：

![](images/多项式拟合1.png)

多项式的一般形式：
$$
y=p_{0}x^n + p_{1}x^{n-1} + p_{2}x^{n-2} + p_{3}x^{n-3} +...+p_{n}
$$

多项式拟合的目的是为了找到一组  $p_0, p_1, ...,  p_n$，使得拟合方程尽可能的与实际样本数据相符合。

假设拟合得到的多项式如下：
$$
f(x)=p_{0}x^n + p_{1}x^{n-1} + p_{2}x^{n-2} + p_{3}x^{n-3} +...+p_{n}
$$
则拟合函数与真实结果的差方如下：
$$
loss = (y_1-f(x_1))^2 + (y_2-f(x_2))^2 + ... + (y_n-f(x_n))^2
$$

那么多项式拟合的过程即为求取一组$p_0, p_1, ...,  p_n$, 使得loss的值最小。在程序中，多项式可以表示为一个数组，格式如下：

```python
f = [-6, 3, 8, 1]
```

表示多项式为：
$$
y=-6x^3 + 3x^2 + 8x + 1
$$
**多项式拟合相关API：**

```python
X = [x1, x2, ..., xn]
Y = [y1, y2, ..., yn]
#根据一组样本，并给出最高次幂，求出拟合系数
np.polyfit(X, Y, 最高次幂)
```

**多项式运算相关API：**

```python
#根据拟合系数与自变量求出拟合值, 由此可得拟合曲线坐标样本数据 [X, Y']
np.polyval(P, X)->Y'

#多项式函数求导，根据拟合系数求出多项式函数导函数的系数
np.polyder(P)->Q 

#已知多项式系数Q 求多项式函数的根（与x轴交点的横坐标）
xs = np.roots(Q)

#两个多项式函数的差函数（对应系数相减）的系数（可以通过差函数的根求取两个曲线的交点）
Q = np.polysub(P1, P2)
```



案例：求多项式 y = 4x<sup>3</sup> + 3x<sup>2</sup> - 1000x + 1曲线驻点的坐标。

```python
'''
1. 求出多项式的导函数
2. 求出导函数的根，若导函数的根为实数，则该点则为曲线驻点。
'''
import numpy as np
import matplotlib.pyplot as mp

x = np.linspace(-20, 20, 1000) #生成数据
P = [4, 3, -1000, 1] #原函数的系数列表
y = np.polyval(P, x) #计算函数的值

Q = np.polyder([4, 3, -1000, 1])  # 求导函数系数
print(Q)
xs = np.roots(Q)  # 求导函数的根（y等于0，此时函数变化率为0，即切线为水平线）
ys = np.polyval(P, xs) #计算变化率为0时的y值

mp.plot(x, y)
mp.scatter(xs, ys, s=80, c="orangered")
mp.show()
```

执行结果：

![](images/导函数求根.png)

案例：使用多项式函数拟合两只股票bhp、vale的差价函数：

```python
'''
1. 计算两只股票的差价
2. 利用多项式拟合求出与两只股票差价相近的多项式系数，最高次为4
'''
import numpy as np
import datetime as dt

#### 1.读取数据
# 日期格式转换函数: 将日月年转换为年月日格式
def dmy2ymd(dmy):
    dmy = str(dmy, encoding="utf-8")
    # 从指定字符串返回一个日期时间对象
    dat = dt.datetime.strptime(dmy, "%d-%m-%Y").date()  # 字符串转日期
    tm = dat.strftime("%Y-%m-%d")  # 日期转字符串
    return tm


dates, bhp_close_prices = np.loadtxt("../da_data/bhp.csv",  # 文件路径
                                     delimiter=",",  # 指定分隔符
                                     usecols=(1, 6),  # 读取的列(下标从0开始)
                                     unpack=True,  # 拆分数据
                                     dtype="M8[D], f8",  # 指定每一列的类型
                                     converters={1: dmy2ymd})  #
dates, vale_close_prices = np.loadtxt("../da_data/vale.csv",  # 文件路径
                                      delimiter=",",  # 指定分隔符
                                      usecols=(1, 6),  # 读取的列(下标从0开始)
                                      unpack=True,  # 拆分数据
                                      dtype="M8[D], f8",  # 指定每一列的类型
                                      converters={1: dmy2ymd})  #

#### 2.绘制图像
import matplotlib.pyplot as mp
import matplotlib.dates as md

# 绘制k线图，x轴为日期
mp.figure("Polyfit", facecolor="lightgray")
mp.title("Polyfit")
mp.xlabel("Date", fontsize=12)
mp.ylabel("Price", fontsize=12)

# 获取坐标轴
ax = mp.gca()
# 设置主刻度定位器为周定位器(每周一显示刻度文本)
ax.xaxis.set_major_locator(md.WeekdayLocator(byweekday=md.MO))
ax.xaxis.set_major_formatter(md.DateFormatter("%d %b %Y"))  # %b表示月份简写
# 设置次刻度定位器为天定位器
ax.xaxis.set_minor_locator(md.DayLocator())
mp.tick_params(labelsize=8)
dates = dates.astype(md.datetime.datetime)

# 绘制差价函数
diff_prices = bhp_close_prices - vale_close_prices
mp.plot(dates, diff_prices, label="diff")

# 寻找拟合差价函数
days = dates.astype("M8[D]").astype("int32")
# 做最小二乘多项式拟合
P = np.polyfit(days,  # x
               diff_prices,  # y
               4)  # 维度
poly_prices = np.polyval(P, days) # 根据求得的系数，重新计算函数值
mp.plot(dates, poly_prices, label="Polyfit line")
mp.gcf().autofmt_xdate()  # 旋转、共享日期显示

mp.grid(linestyle="--")
mp.legend()
mp.show()
```

执行结果：

![](images/股票差函数多项式拟合.png)

多项式拟合的注意事项：

- 多项式拟合不能在数据样本之外的范围做预测

- 多项式拟合时容易造成过拟合（函数和样本拟合度太高，样本以外的数据则拟合度很低）



### 3. 数据平滑

数据的平滑处理通常包含有降噪、拟合等操作。降噪的功能意在去除额外的影响因素，拟合的目的意在数学模型化，可以通过更多的数学方法识别曲线特征。

案例：绘制两只股票收益率曲线。收益率 =（后一天收盘价-前一天收盘价） / 前一天收盘价。

第一步：使用卷积完成数据降噪

```python
# 数据平滑示例
import numpy as np
import datetime as dt


#### 1.读取数据
# 日期格式转换函数: 将日月年转换为年月日格式
def dmy2ymd(dmy):
    dmy = str(dmy, encoding="utf-8")
    # 从指定字符串返回一个日期时间对象
    dat = dt.datetime.strptime(dmy, "%d-%m-%Y").date()  # 字符串转日期
    tm = dat.strftime("%Y-%m-%d")  # 日期转字符串
    return tm


dates, bhp_close_prices = np.loadtxt("../da_data/bhp.csv",  # 文件路径
                                     delimiter=",",  # 指定分隔符
                                     usecols=(1, 6),  # 读取的列(下标从0开始)
                                     unpack=True,  # 拆分数据
                                     dtype="M8[D], f8",  # 指定每一列的类型
                                     converters={1: dmy2ymd})  #
dates, vale_close_prices = np.loadtxt("../da_data/vale.csv",  # 文件路径
                                      delimiter=",",  # 指定分隔符
                                      usecols=(1, 6),  # 读取的列(下标从0开始)
                                      unpack=True,  # 拆分数据
                                      dtype="M8[D], f8",  # 指定每一列的类型
                                      converters={1: dmy2ymd})  #

import matplotlib.pyplot as mp
import matplotlib.dates as md

# 计算收益率
# diff: 数组中后一个元素减去前一个元素，形成的新数组
bhp_returns = np.diff(bhp_close_prices) / bhp_close_prices[:-1]
vale_returns = np.diff(vale_close_prices) / vale_close_prices[:-1]
dates = dates[:-1]

# 卷积降噪
# hanning窗: 其中有一个性质, 加hanning窗后，其幅值减为原来的一半
con_kernel = np.hanning(8)
con_kernel /= con_kernel.sum()  # 数据归一化
bhp_returns_con = np.convolve(bhp_returns, con_kernel, "valid")  # 卷积运算
vale_returns_con = np.convolve(vale_returns, con_kernel, "valid")  # 卷积运算

# 绘制收益曲线
mp.figure('BHP VALE RETURNS', facecolor='lightgray')
mp.title('BHP VALE RETURNS', fontsize=20)
mp.xlabel('Date')
mp.ylabel('Price')
ax = mp.gca()
ax.xaxis.set_major_locator(md.WeekdayLocator(byweekday=md.MO))
ax.xaxis.set_minor_locator(md.DayLocator())
ax.xaxis.set_major_formatter(md.DateFormatter('%Y %m %d'))
dates = dates.astype('M8[D]')
# 绘制收益线
mp.plot(dates, bhp_returns, color='dodgerblue',
        linestyle='--', label='bhp_returns', alpha=0.3)
mp.plot(dates, vale_returns, color='orangered',
        linestyle='--', label='vale_returns', alpha=0.3)

# 绘制卷积降噪曲线
mp.plot(dates[7:], bhp_returns_con, color="red", label="bhp_returns_con")
mp.plot(dates[7:], vale_returns_con, color="blue", label="vale_returns_con")

mp.grid()
mp.gcf().autofmt_xdate()  # 旋转、共享日期显示
mp.show()
```

执行结果：

![](images/降噪曲线.png)



第二步：对处理过的股票收益率做多项式拟合

```python
# 多项式拟合，并绘制曲线
# 拟合这两条曲线，获取两组多项式系数
dt = dates.astype(int)
bhp_p = np.polyfit(dt[7:], bhp_returns_con, 3)#求系数
bhp_polyfit_y = np.polyval(bhp_p, dt[7:])#求函数值

vale_p = np.polyfit(dt[7:], vale_returns_con, 3)#求系数
vale_polyfit_y = np.polyval(vale_p, dt[7:])#求函数值

# 绘制拟合线
mp.plot(dates[7:], bhp_polyfit_y, color='dodgerblue',
        label='bhp_returns_polyfit', linestyle="--")
mp.plot(dates[7:], vale_polyfit_y, color='orangered',
        label='vale_returns_polyfit', linestyle="--")
```

执行结果（不透明虚线部分）：

![](images/降噪曲线差函数的根.png)



第三步：通过获取两个函数的交点可以分析两只股票的投资收益比

```python
# 求差函数，并求差函数的根
sub_p = np.polysub(bhp_p, vale_p) #求差函数
roots_x = np.roots(sub_p) #求差函数的根
print(roots_x.astype("M8[D]"))
```

执行结果：

```
['2011-03-22' '2011-03-10' '2011-02-20']
```

### 4. 基于函数矢量化的股票回测模型

函数的矢量化指通过一个只能处理标量数据的函数得到一个可以处理矢量数据的函数，从而可以对大量数据进行矢量化计算。

numpy提供了vectorize函数，可以把处理标量的函数矢量化，返回的函数可以直接处理ndarray数组。

```python
# vectorize函数矢量化示例
import math
import numpy as np


def func(x, y):
    return math.sqrt(x ** 2 + y ** 2)


# 标量计算
x, y = 3, 4	
print(func(x, y))

# 矢量化计算
X = np.array([3, 6, 9])
Y = np.array([4, 8, 12])

vect_func = np.vectorize(func)  # 创建函数矢量化对象

print(vect_func(X, Y))
```

执行结果：

```
5.0
[ 5. 10. 15.]
```



numpy还提供了frompyfuc函数，也可以完成与vectorize相同的功能：

```python
# 把foo转换成矢量函数
# 原型：frompyfunc(func, nin, nout)
# func: 要矢量化的函数
# nin:输入参数个数
# nout:返回值个数
fun = np.frompyfunc(foo, 2, 1)
fun(X, Y)
```



案例：定义一种投资策略，传入某日期，基于均线理论返回是否应该按收盘价购买，并通过历史数据判断这种策略是否值得实施。

```python
import numpy as np
import matplotlib.pyplot as mp
import datetime as dt
import matplotlib.dates as md

# 日期格式转换函数: 将日月年转换为年月日格式
def dmy2ymd(dmy):
    dmy = str(dmy, encoding="utf-8")
    # 从指定字符串返回一个日期时间对象
    dat = dt.datetime.strptime(dmy, "%Y/%m/%d").date()
    tm = dat.strftime("%Y-%m-%d")  # 格式化
    return tm

dates, opening_prices, highest_prices, lowest_prices, closing_prices, ma5, ma10= \
    np.loadtxt("../data/pfyh.csv", #文件路径
               delimiter=",", #指定分隔符
               usecols=(0,1,2,3,4,5,6), #读取的列(下标从0开始)
               unpack=True, #拆分数据
               dtype="M8[D], f8, f8, f8, f8, f8, f8") #
mp.plot(dates, closing_prices)
mp.show()
# 定义一种投资策略，传入日期，基于均线理论返回是否应该按收盘价购买 1:应买入  0:应持有现状  -1:应卖出
def profit(m8date):
    mma5 = ma5[dates < m8date]
    mma10 = ma10[dates < m8date]
    # 至少两天数据才可以进行预测
    if mma5.size < 2:
        return 0
    # 出现金叉，则建议买入
    if (mma5[-2] <= mma10[-2]) and (mma5[-1] >= mma10[-1]):
        return 1
    # 出现死叉，则建议卖出
    if (mma5[-2] >= mma10[-2]) and (mma5[-1] <= mma10[-1]):
        return -1
    return 0

# 矢量化投资函数
vec_func = np.vectorize(profit)
# 使用适量换函数计算收益
profits = vec_func(dates)
print(profits)

# 定义资产
assets = 1000000
stocks = 0
payment_price = 0
status = 0
for index, profit in enumerate(profits):
    current_price = closing_prices[index]
    # 如果是买入并且赔了的状态，若已经跌出5%，则强制卖出
    if status == 1:
        payment_assets = payment_price * stocks
        current_assets = current_price * stocks
        if (payment_assets > current_assets) and ((payment_assets-current_assets) > payment_assets *0.05):
            payment_price = current_price
            assets = assets + stocks * payment_price
            stocks = 0
            status = -1
            print('止损：dates:{}, curr price:{:.2f}, assets:{:.2f}, stocks:{:d}'.format(dates[index], current_price, assets, stocks))
    if (profit == 1) and (status != 1): # 买入
        payment_price = current_price
        stocks = int(assets / payment_price)
        assets = assets - stocks * payment_price
        status = 1
        print('买入：dates:{}, curr price:{:.2f}, assets:{:.2f}, stocks:{:d}'.format(dates[index], current_price, assets, stocks))
    if (profit == -1) and (status != -1): # 卖出
        payment_price = current_price
        assets = assets + stocks * payment_price
        stocks = 0
        status = -1
        print('卖出：dates:{}, curr price:{:.2f}, assets:{:.2f}, stocks:{:d}'.format(dates[index], current_price, assets, stocks))
    print('持有：dates:{}, curr price:{:.2f}, assets:{:.2f}, stocks:{:d}'.format(dates[index], current_price, assets, stocks))
```

## 八、矩阵

矩阵是numpy.matrix类型的对象，该类继承自numpy.ndarray，任何针对多维数组的操作，对矩阵同样有效，但是作为子类矩阵又结合其自身的特点，做了必要的扩充，比如：乘法计算、求逆等。

### 1. 矩阵对象的创建

```python
# 通过ndarray对象创建matrix对象
numpy.matrix(
    ary,		# 任何可被解释为矩阵的二维容器
  	copy=True	# 是否复制数据(缺省值为True，即复制数据)
)
```

```python
# 等价于：numpy.matrix(..., copy=False)
# 由该函数创建的矩阵对象与参数中的源容器一定共享数据，无法拥有独立的数据拷贝
numpy.mat(任何可被解释为矩阵的二维容器)
```

```python
# 该函数可以接受字符串形式的矩阵描述：
# 数据项通过空格分隔，数据行通过分号分隔。例如：'1 2 3; 4 5 6'
numpy.mat(拼块规则)
```

示例：创建matrix

```python
# 创建matrix操作
import numpy as np

arr = np.arange(1, 10).reshape(3, 3)
print(arr)

# 第一种方式
m = np.matrix(arr, copy=True)
print(m)
print(m.shape)
print(type(m))

# 第二种方式:共享方式
m2 = np.mat(arr)
print(m2)

# 第三种方式
m3 = np.mat("1 2 3;4 5 6.0")
print(m3)
```



### 2. 矩阵的乘法运算

```python
# 矩阵乘法
import numpy as np

arr = np.array([[1, 1, 1],
                [2, 2, 2],
                [3, 3, 3]])
# 数组相乘, 各对应位置元素相乘
print(arr * arr)

# 矩阵相乘，第n行乘m列之和，作为结果的n,m个元素
# 矩阵相乘，第一个矩阵行数必须等于第二个矩阵列数
m = np.mat(arr)
print(m * m)
```



### 3. 矩阵的逆矩阵

若两个矩阵A、B满足：AB = E （E为单位矩阵），则称B为A的逆矩阵。

**单位矩阵**

在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的1，这种矩阵被称为单位矩阵。它是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1，除此以外全都为0，记为$I_n$或$E_n$ ，通常用I或E来表示。根据单位矩阵的特点，任何矩阵与单位矩阵相乘都等于本身，而且单位矩阵因此独特性有广泛用途。以下是一个单位矩阵示例：
$$
E_3 =
\left[ \begin{array}{ccc}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1\\
\end{array} 
\right ]
$$
逆矩阵示例：

```python
e = np.mat("1 2 6; 3 5 7; 4 8 9")
print(e.I)
print(e * e.I)

# 非方阵的逆（称为广义逆矩阵）
e = np.mat("1 2 6; 3 5 7")
print(e.I)
print(e * e.I)
```

注意：在计算过程中，可能出现如下错误，说明该矩阵不可逆。

```
numpy.linalg.LinAlgError: Singular matrix
```



### 4. ndarray提供的矩阵API

ndarray提供了方法让多维数组替代矩阵的运算： 

```python
a = np.array([
    [1, 2, 6],
    [3, 5, 7],
    [4, 8, 9]])
# 点乘法求ndarray的点乘结果，与矩阵的乘法运算结果相同
k = a.dot(a)
print(k)
# linalg模块中的inv方法可以求取a的逆矩阵
l = np.linalg.inv(a)
print(l)
```

执行结果：

```
[[ 31  60  74]
 [ 46  87 116]
 [ 64 120 161]]
[[-0.73333333  2.         -1.06666667]
 [ 0.06666667 -1.          0.73333333]
 [ 0.26666667  0.         -0.06666667]]
```

### 5. 矩阵应用

案例：解线性方程组

假设一帮孩子和家长出去旅游，去程坐的是bus，小孩票价为3元，家长票价为3.2元，共花了118.4；回程坐的是Train，小孩票价为3.5元，家长票价为3.6元，共花了135.2。分别求小孩和家长的人数。使用矩阵求解。表达成方程为：
$$
3x + 3.2y = 118.4\\
3.5x + 3.6y = 135.2
$$
表示成矩阵相乘：
$$
\left[ \begin{array}{ccc}
	3 & 3.2 \\
	3.5 & 3.6 \\
\end{array} \right]
\times
\left[ \begin{array}{ccc}
	x \\
    y \\
\end{array} \right]
=
\left[ \begin{array}{ccc}
	118.4 \\
	135.2 \\
\end{array} \right]
$$


```python
import numpy as np

# 解方程
prices = np.mat('3 3.2; 3.5 3.6')
totals = np.mat('118.4; 135.2')

x = np.linalg.lstsq(prices, totals)[0]  # 求最小二乘解
print(x)

x = np.linalg.solve(prices, totals)  # 求解线性方程的解
print(x)

x = prices.I * totals  # 利用矩阵的逆进行求解
print(x)
```

案例：斐波那契数列

1	1	 2	 3	5	8	13	21	34 ...

```python
X      1   1    1   1    1   1
       1   0    1   0    1   0
    --------------------------------
1  1   2   1    3   2    5   3
1  0   1   1    2   1    3   2
 F^1    F^2      F^3 	  F^4  ...  f^n

```

**代码**

```python
import numpy as np
n = 35

# 使用递归实现斐波那契数列
def fibo(n):
    return 1 if n < 3 else fibo(n - 1) + fibo(n - 2)
print(fibo(n))

# 使用矩阵实现斐波那契数列
print(int((np.mat('1. 1.; 1. 0.') ** (n - 1))[0, 0]))
```

## 十、数据特征提取

### 1. 特征值和特征向量

对于n阶方阵A，如果存在数a和非零n维列向量x，使得Ax=ax，则称a是矩阵A的一个特征值，x是矩阵A属于特征值a的特征向量。

特征向量几何意义为：矩阵对某一个向量或某些向量只发生伸缩变换，不对这些向量产生旋转的效果，那么这些向量就称为这个矩阵的特征向量，伸缩的比例就是特征值。

```python
#已知n阶方阵A， 求特征值与特征数组
# eigvals: 特征值数组
# eigvecs: 特征向量数组 
eigvals, eigvecs = np.linalg.eig(A)
#已知特征值与特征向量，求方阵
S = np.mat(eigvecs) * np.mat(np.diag(eigvals)) * np.mat(eigvecs逆) 
```



案例一：通过特征值、特征向量计算原矩阵、还原矩阵

```python
# 特征值与特征向量示例
import numpy as np

A = np.mat("3 4 6; 2 3 -1; 5 7 11")
print(A)

# 提取特征值、特征向量
eigen_vals, eigen_vecs = np.linalg.eig(A)
print(eigen_vals)
print("-" * 40)
print(eigen_vecs)

# 求原方阵 特征向量 * 对角阵 * 逆
A2 = eigen_vecs * np.diag(eigen_vals) * eigen_vecs.I
print(A2)
print("-" * 40)

# 抹掉一部分特征值，对矩阵进行还原
eigen_vals[2:] = 0 # 抹掉一部分特征值
A3 = eigen_vecs * np.diag(eigen_vals) * eigen_vecs.I
print(A3)
```

执行结果：

```
[[ 3  4  6]
 [ 2  3 -1]
 [ 5  7 11]]
[13.8556546  0.1443454  3.       ]
----------------------------------------
[[ 0.48628397  0.81808984  0.26726124]
 [ 0.00910259 -0.57505923 -0.80178373]
 [ 0.87375342 -0.00599085  0.53452248]]
[[ 3.  4.  6.]
 [ 2.  3. -1.]
 [ 5.  7. 11.]]
----------------------------------------
[[ 3.67741935  4.96774194  5.61290323]
 [-0.03225806  0.09677419  0.16129032]
 [ 6.35483871  8.93548387 10.22580645]]
```



案例二：读取图片的亮度矩阵，提取特征值与特征向量，保留部分特征值，重新生成新的亮度矩阵，绘制图片。

```python
'''
利用特征值与特征向量处理图片
'''
import numpy as np
import scipy.misc as sm
import matplotlib.pyplot as mp


original = sm.imread('../da_data/lily.jpg', True)
#提取特征值
eig_vals, eig_vecs = np.linalg.eig(original)
eig_vals[50:] = 0 #抹去一部分值
print(np.diag(eig_vals).shape)

# 还原图像
original2 = np.mat(eig_vecs) * np.mat(np.diag(eig_vals)) * np.mat(eig_vecs).I
mp.figure("Lily Features")
mp.subplot(121)
mp.xticks([])
mp.yticks([])
mp.imshow(original, cmap='gray')#显示图片

mp.subplot(122)
mp.xticks([])
mp.yticks([])
mp.imshow(original2.real, cmap='gray')#显示图片
mp.tight_layout()
mp.show()
```

执行结果：

![](images/eigen_img.png)



### 2、奇异值分解

奇异值分解（Singular Value Decomposition）是指：有一个矩阵M，可以分解为3个矩阵U、S、V，使得U x S x V等于M。U与V都是正交矩阵（乘以自身的转置矩阵结果为单位矩阵）。那么S矩阵主对角线上的元素称为矩阵M的奇异值，其它元素均为0。

奇异值与特征值提取区别：奇异值支持非方阵运算。

正交矩阵：乘以自身的转置矩阵结果为单位矩阵，其几何意义在于保持原点不变、长度不变的线性变换。
$$
A*A^T = E
$$


```python
import numpy as np
M = np.mat('4 11 14; 8 7 -2') #构建一个非方阵
#print(M)
#提取奇异值，分解得到三个矩阵
U, sv, V = np.linalg.svd(M, 
                         full_matrices=False) #返回非方阵
# U和V是正交矩阵
print(U * U.T)
print(V * V.T)
print(sv)
#sv[1:] = 0 # 去掉一部分值
S = np.diag(sv)
print(S)
print(U * S * V)
```



案例：读取图片的亮度矩阵，提取奇异值与两个正交矩阵，保留部分奇异值，重新生成新的亮度矩阵，绘制图片。

```python
import numpy as np
import matplotlib.pyplot as mp
import scipy.misc as sm

original = sm.imread('../da_data/lily.jpg', True)
#提取奇异值  sv
U, sv, V = np.linalg.svd(original)
print(U.shape, sv.shape, V.shape)

sv[50:] = 0 #抹掉部分特征

# 还原矩阵
original2 = np.mat(U) * np.mat(np.diag(sv)) * np.mat(V)

mp.figure("Lily Features")
mp.subplot(121)
mp.xticks([])
mp.yticks([])
mp.tight_layout()
mp.imshow(original, cmap='gray')

mp.subplot(122)
mp.xticks([])
mp.yticks([])
mp.imshow(original2.real, cmap='gray')
mp.show()
```

执行结果：

![](images/svd_lily.png)



### 3、快速傅里叶变换(fft)

#### 1. 傅里叶定理

法国科学家傅里叶提出傅里叶定理，任何一条周期曲线，无论多么跳跃或不规则，都能表示成一组光滑正弦曲线叠加之和。

**合成方波**

一个方波由如下参数的正弦波叠加而成：
$$
y = 4\pi \times sin(x) \\
y = \frac{4\pi}{3} \times sin(3x) \\
...\\
...\\
y = \frac{4\pi}{2n-1} \times sin((2n-1)x)
$$
曲线叠加的越多，越接近方波。所以可以设计一个函数，接收曲线的数量n作为参数，返回一个矢量函数，该函数可以接收x坐标数组，返回n个正弦波叠加得到的y坐标数组。

```python
import numpy as np
import matplotlib.pyplot as mp

n = 1000
x = np.linspace(-2 * np.pi, 2 * np.pi, n)
y = np.zeros(n)

for i in range(1, n + 1):
    y += 4 / ((2 * i - 1) * np.pi) * np.sin((2 * i - 1) * x)

mp.plot(x, y, label='n=1000')
mp.legend()
mp.show()
```

执行结果：

![](C:/Users/xuming/Desktop/20.02%E7%A0%94%E5%8F%91/%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%99/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/images/square_wave.png)



#### 2. 傅里叶变换

傅里叶变换即是将不规则曲线拆解为一组光滑正弦曲线的过程。傅立叶变换是一种分析信号的方法，它可分析信号的成分，也可用这些成分合成信号。

傅里叶变换的目的是可将时域（以时间作为参照来观察动态世界的方法我们称其为时域分析）上的信号转变为频域（描述信号在频率方面特性时用到的一种坐标系）上的信号。一般来说，时域的表示较为形象与直观，频域分析则更为简练，剖析问题更为深刻和方便。随着域的不同，对同一个事物的了解角度也就随之改变，因此在时域中某些不好处理的地方，在频域就可以较为简单的处理。这就可以大量减少处理信号的信号量。傅里叶变换可以理解成换了一个角度来看数据。

假设有一时间域函数：**y = f(x)**，根据傅里叶的理论它可以被分解为一系列正弦函数的叠加，他们的振幅A，频率&omega;或初相位&phi;不同：
$$
y = A_1sin(\omega_1x+\phi_1) +  A_2sin(\omega_2x+\phi_2) +  A_3sin(\omega_3x+\phi_3) + R
$$

所以傅里叶变换可以把一个比较复杂的函数转换为多个简单函数的叠加，看问题的角度也从时间域转到了频率域，有些的问题处理起来就会比较简单。

![](images/ftt.png)

#### 3. 傅里叶变化的应用

例如，我们需要对一个信号进行检测，但是实际检测的过程中会出现各种各样的干扰（静电干扰，噪声干扰等等）。假设我们需要检测的原始信号是这样的：

![](images/fft_01_原始图像.png)

但是这个信号受到了这样一个高频噪声的干扰：

![](images/fft_02_干扰信号.png)

实际检测到的信号：

![](images/fft_03_受到干扰的图像.png)

利用傅里叶变换进行时域到频域转换：

![](images/fft_04_傅里叶变换.png)

删除高频干扰信号后还原的信号：

![](images/fft_04_删除高频信号后还原的信号.png)



#### 4. 傅里叶变换相关函数

导入快速傅里叶变换所需模块

```python
import numpy.fft as nf
```

通过采样数与采样周期求得傅里叶变换分解所得曲线的**频率序列**

```python
# 采样数量：一段时间内的采样点
# 采样周期：多长时间采样一次
freqs = nf.fftfreq(采样数量, 采样周期)
```

通过原函数值的序列j经过快速傅里叶变换得到一个**复数数组**，复数的模代表的是**振幅**，复数的辐角代表**初相位**

```python
# 将原函数拆分成一组正弦函数
nf.fft(原函数数组) -> 复数数组(表示一组正弦函数)
```

通过 **复数数组** 经过逆向傅里叶变换得到**合成的函数值数组**

```python
nf.ifft(复数数组)->原函数值数组
```

案例一：针对方波，绘制时域图与频域图。

```python
# 合成波形
import numpy as np
import numpy.fft as nf
import matplotlib.pyplot as mp

times = np.linspace(0, 2 * np.pi, 201) #产生一组均匀的值

# 通过多个正弦波合成波形
sigs1 = 4 / (1 * np.pi) * np.sin(1 * times)
sigs2 = 4 / (3 * np.pi) * np.sin(3 * times)
sigs3 = 4 / (5 * np.pi) * np.sin(5 * times)
sigs4 = 4 / (7 * np.pi) * np.sin(7 * times)
sigs5 = 4 / (9 * np.pi) * np.sin(9 * times)
sigs6 = sigs1 + sigs2 + sigs3 + sigs4 + sigs5

# 原始波形
mp.subplot(211)
mp.xlabel('', fontsize=12)
mp.ylabel('Signal', fontsize=12)
mp.tick_params(labelsize=10)
mp.plot(times, sigs1, label=r'$\omega$='+str(round(1 / (2 * np.pi),3)))
mp.plot(times, sigs2, label=r'$\omega$='+str(round(3 / (2 * np.pi),3)))
mp.plot(times, sigs3, label=r'$\omega$='+str(round(5 / (2 * np.pi),3)))
mp.plot(times, sigs4, label=r'$\omega$='+str(round(7 / (2 * np.pi),3)))
mp.plot(times, sigs5, label=r'$\omega$='+str(round(9 / (2 * np.pi),3)))

# 合成波形
mp.subplot(212)
mp.xlabel('Time', fontsize=12)
mp.ylabel('Composed Wave', fontsize=12)
mp.tick_params(labelsize=10)
mp.plot(times, sigs6, label=r'$\omega$='+str(round(1 / (2 * np.pi),3)))

mp.grid(linestyle=':')
mp.legend()
mp.show()
```

执行结果：

![](images/合成波形.png)

案例二：针对合成波做快速傅里叶变换，得到一组复数序列；再针对该复数序列做逆向傅里叶变换得到新的合成波并绘制。

```python
# 对合成的方波做傅里叶变换
import numpy as np
import matplotlib.pyplot as mp
import numpy.fft as nf

n = 1000
x = np.linspace(-2 * np.pi, 2 * np.pi, n)
y = np.zeros(n)

for i in range(1, n + 1):
    y += 4 / ((2 * i - 1) * np.pi) * np.sin((2 * i - 1) * x)

mp.plot(x, y, label='n=1000')

# 对合成的方波做傅里叶变换
complex_arr = nf.fft(y) # 傅里叶变换
print(complex_arr.shape, complex_arr.dtype)

# 逆向傅里叶变换
y2 = nf.ifft(complex_arr)
mp.plot(x, y2, label="y2", color="blue", linestyle=":",
        linewidth=5, alpha=0.2)

mp.legend()
mp.show()
```

执行结果：

![](images/ifft.png)



案例三：针对合成波做快速傅里叶变换，得到分解波数组的频率、振幅、初相位数组，并绘制频域图像。在上述示例中加入以下代码：

```python
# 绘制频域图（频率/能量图像）
freqs = nf.fftfreq(y2.size,  # 采样点数量
                   x[1] - x[0])  # 采样周期
pows = np.abs(complex_arr)  # 复数的模(代表能量)
mp.plot(freqs[freqs > 0], pows[freqs > 0], color="red", label="Frequency")
```

执行结果：

![](images/frequency.png)



#### 5. 基于傅里叶变换的频域滤波

含噪信号是高能信号与低能噪声叠加的信号，可以通过傅里叶变换的频域滤波实现降噪。

通过FFT使含噪信号转换为含噪频谱，去除低能噪声，留下高能频谱后再通过IFFT留下高能信号。

案例：基于傅里叶变换的频域滤波为音频文件去除噪声。

1. 读取音频文件，获取音频文件基本信息：采样个数，采样周期，与每个采样的声音信号值。绘制音频时域的：时间/位移图像。
2. 基于傅里叶变换，获取音频频域信息，绘制音频频域的：频率/能量图像。
3. 将低频噪声去除后绘制音频频域的：频率/能量图像。
4. 基于逆向傅里叶变换，生成新的音频信号，绘制音频时域的：时间/位移图像。
5. 重新生成音频文件。

```python
# 基于傅里叶变换的频域滤波（降噪）
import numpy as np
import numpy.fft as nf
import scipy.io.wavfile as wf  # 音频处理模块
import matplotlib.pyplot as mp

# 读取音频文件，返回采样率、采样位移
sample_rate, noised_sigs = wf.read("../da_data/noised.wav")  # 读取音频文件
print("sample_rate:", sample_rate)  # 采样率
print("noised_sigs.shape:", noised_sigs.shape)  # 采样位移

# 1. 绘制音频时域时间/位移图像
noised_sigs = noised_sigs / (2 ** 15)  # 缩小位移的范围，用于显示
times = np.arange(noised_sigs.size) / sample_rate  # 计算每个采样点的时间点

mp.figure("Filter", facecolor="lightgray")
mp.subplot(221)
mp.title("Time Domain", fontsize=16)
mp.ylabel("Signal", fontsize=12)
mp.grid(linestyle=":")
mp.plot(times[:178], noised_sigs[:178],  # 只看前178个采样点
        color="dodgerblue", label="Noised")

# 2. 基于傅里叶变化，获取音频频域信息
freqs = nf.fftfreq(times.size, times[1] - times[0])
complex_arr = nf.fft(noised_sigs)  # 傅里叶变换
pows = np.abs(complex_arr)
# 绘制频域能量图像
mp.subplot(222)
mp.title("Frequency Domain", fontsize=16)
mp.ylabel("Power", fontsize=12)
mp.grid(linestyle=":")
mp.semilogy(freqs[freqs > 0], pows[freqs > 0],  # 只看频率大于0的部分
            color="orangered", label="Noised")  # 采用半对数坐标

# 3. 将低能噪声去除，绘制音频/能量图像
# 找到能量最大的采样点的位置，去除其它的
fund_freq = freqs[pows.argmax()]  # 能量最大的频率
noised_idx = np.where(freqs != fund_freq)  # 噪声点的下标
complex_arr[noised_idx] = 0  # 将噪声位置的数据抹掉
pows = np.abs(complex_arr)  # 去噪后的能量数据

mp.subplot(223)
mp.title("Frequency Domain", fontsize=16)
mp.ylabel("Power", fontsize=12)
mp.grid(linestyle=":")
mp.plot(freqs[freqs > 0], pows[freqs > 0],  # 只看频率大于0的部分
        color="orangered", label="Filtered")  # 采用半对数坐标

# 4. 做逆向傅里叶变换，生成降噪后的音频时域图
filter_sigs = nf.ifft(complex_arr)  # 逆向傅里叶变换
mp.subplot(224)
mp.title("Filtered Signal", fontsize=16)
mp.ylabel("Signal", fontsize=12)
mp.grid(linestyle=":")
mp.plot(times[:178], filter_sigs[:178],  # 只看前178个采样点
        color="dodgerblue", label="Filtered")

# 5. 将降噪后的数组还原成音频
wf.write("../da_data/filtered_777.wav",  # 文件路径
         sample_rate,  # 采样率
         (filter_sigs * 2 ** 15).astype(np.int16))  # 数据

mp.tight_layout()
mp.show()
```

执行结果：

![](images/ftt去噪.png)



## 十一、随机数与概率分布

生成服从特定统计规律的随机数序列。

一组随机数可能呈现如下分布：

```
统计班级同学体重：[63.2, 76.5, 65.7, 68.9, 59.4 ... ]
统计班级同学身高：[163.2, 176.5, 165.7, 168.9, 159.4 ... ]
统计班级同学到班时间：['07:20:22','07:30:48','07:21:23','07:24:58' ...]
```

又或者呈现如下分布：

```
统计班级同学体重级别：[偏轻, 中等, 偏重, 超重, 中等, 偏重, 超重, 中等, 偏重...]
统计班级同学身高级别：[偏轻, 中等, 中等, 中等, 中等, 偏重, 中等, 中等, 偏重...]
统计最近班级同学迟到人数（共10人）：[0, 1, 3, 0, 0, 1, 2, 0, 0, 0 ....]
```

### 1. 二项分布（binomial）

二项分布就是重复n次独立事件的伯努利试验（Bernoulli experiment）。在每次试验中只有两种可能的结果，而且两种结果发生与否互相对立，并且相互独立，事件发生与否的概率在每一次独立试验中都保持不变，例如抛硬币。

```python
# 产生size个随机数，每个随机数来自n次尝试中的成功次数，其中每次尝试成功的概率为p
np.random.binomial(n, p, size)
```

二项分布可以用于求如下场景的概率的近似值：

1. 某人投篮命中率为0.3，投10次，进5个球的概率。

```python
sum(np.random.binomial(10, 0.3, 200000) == 5) / 200000
```

2. 某人打客服电话，客服接通率是0.6，一共打了3次，都没人接的概率。

```python
sum(np.random.binomial(3, 0.6, 200000) == 0) / 200000
```

示例：模拟某人以30%命中率投篮，每次投10个，计算并打每种进球可能的概率

```python
# 二项式分布示例
import numpy as np
import matplotlib.pyplot as mp

# binomial: 从二项分布中抽取样本
# n:尝试次数  p:概率
r = np.random.binomial(10, 0.3, 200000)
# print(r)
total = 0
probs = []
for i in range(11):
    n = sum(r == i) / 200000
    print("i:", n)
    probs.append(n)
    total += n
print(total)

# 可视化
x = np.arange(0, 11)  # 产生均匀数组，长度等同于apples

mp.bar(x,  # 横轴数据
       probs,  # 纵轴数据
       0.4,  # 柱体宽度
       color='dodgerblue',
       label='probs')

mp.legend()
mp.show()
```

执行结果：

![](images/binomial.png)



### 2. 超几何分布(hypergeometric)

超几何分布是统计学上一种离散概率分布。它描述了从有限N个物件（其中包含M个指定种类的物件）中抽出n个物件，成功抽出该指定种类的物件的次数（不放回）。以下是一组超几何分布的示例：

（1）10件产品中含有3件次品，从中任意取4件产品，所取出的次品件数服从超几何分布；
（2）袋中有8红球4白球，从中任意摸出5个球，摸出红球个数服从超几何分布；
（3）某班45个学生，女生20人，现从中选7人做代表，代表中所含女生的人数服从超几何分布；
（4）15张卡片中含有5件写有“奖”字，从中任意取3件产品，所取出的卡片中含有奖字的卡片张数服从超几何分布；

（5）10位代表中有5位支持候选人A，随机采访3人，其中支持候选人A的人数服从超几何分布；
（6）盘中装有10个粽子，豆沙粽2个，肉粽3个，白粽5个，从中任选3个，取到的豆沙粽的个数服从超几何分布。

API介绍：

```python
# 产生size个随机数，每个随机数t为在总样本中随机抽取nsample个样本后好样本的个数，总样本由ngood个好样本和nbad个坏样本组成
np.random.hypergeometric(ngood, nbad, nsample, size)
```



示例一：从6个好苹果、4个坏苹果中抽取3个苹果，返回好球的数量（执行10次）

```python
import numpy as np

# 从6个好球、4个坏球中抽取3个球，返回好球的数量（执行10次）
n = np.random.hypergeometric(6, 4, 3, 10)
print(n)
print(n.mean())
```

执行结果：

```
[2 2 3 1 2 2 1 3 2 2]
2.0
```



### 3. 正态分布(normal)

```python
# 产生size个随机数，服从标准正态(期望=0, 标准差=1)分布。
np.random.normal(size)
# 产生size个随机数，服从正态分布(期望=1, 标准差=10)。
np.random.normal(loc=1, scale=10, size)
```

$$
标准正态分布概率密度: \frac{e^{-\frac{x^2}{2}}}{\sqrt{2\pi}}
$$

案例：生成10000个服从正态分布的随机数并绘制随机值的频数直方图。

```python
import numpy as np
import matplotlib.pyplot as mp

samples = np.random.normal(size=10000)

mp.figure('Normal Distribution',facecolor='lightgray')
mp.title('Normal Distribution', fontsize=20)
mp.xlabel('Sample', fontsize=14)
mp.ylabel('Occurrence', fontsize=14)
mp.tick_params(labelsize=12)
mp.grid(axis='y', linestyle=':')
mp.hist(samples, 100, normed=True,
               edgecolor='steelblue',
               facecolor='deepskyblue',
               label='Normal')[1]
mp.legend()
mp.show()
```

执行结果：

![](images/normal_distribution.png)



## 十二、杂项功能

### 1. 排序

#### 1）联合间接排序

联合间接排序支持为待排序列排序，若待排序列值相同，则利用参考序列作为参考继续排序。最终返回排序过后的有序索引序列。

```python
indices = numpy.lexsort((参考序列, 待排序列))
```

案例：先按价格排序，再按销售量倒序排列。

```python
# 联合间接排序
import numpy as np

names = np.array(["Apple", "Huawei", "Mi", "Oppo", "Vivo"])
prices = np.array([8888, 5888, 2999, 3999, 3999])
volumns = np.array([60, 110, 40, 50, 70])

# 排序：先按价格排序，然后按销量排序
indeces = np.lexsort((volumns, prices))  # 排序后返回索引列表（升序）
print(indeces)
indeces = np.lexsort((-volumns, prices))  # 按销量倒序排列
print(indeces)
```

执行结果：

```
[2 3 4 1 0]
[2 4 3 1 0]
```

#### 2）复数数组排序

按照实部的升序排列，对于实部相同的元素，参考虚部的升序，直接返回排序后的结果数组。

```python
numpy.sort_complex(复数数组)
```

#### 3）插入排序

若有需求需要向有序数组中插入元素，使数组依然有序，numpy提供了searchsorted方法查询并返回可插入位置数组。

```python
indices = numpy.searchsorted(有序数组, 待插入数据数组)
```

调用numpy提供了insert方法将待插入元素数组中的元素，按照位置数组中的位置，插入到目标数组中，返回结果数组。

```python
numpy.insert(A, indices, B) # 向A数组中的indices位置插入B数组中的元素
```

案例：

```python
import numpy as np

a = np.array([1, 2, 4, 5, 6, 8, 9])
b = np.array([7, 3])

c = np.searchsorted(a, b) #返回可插入元素的位置
print("pos:", c)

d = np.insert(a, c, b) # 向a数组中按照c指定的位置插入b数组中的元素
print(d)
```

执行结果：

```
pos: [5 2]
[1 2 3 4 5 6 7 8 9]
```

### 2. 插值

需求：统计各小区彩民买彩票的情况：

| 彩民数量 | 彩票购买量 |
| -------- | ---------- |
| 30       | 100注      |
| 40       | 120注      |
| 50       | 135注      |
| 60       | 155注      |
| 45       | -          |
| 65       | 170注      |

对于有缺失值的样本，如何处理？可以赋予一个合适的值，这就是插值操作。



scipy提供了常见的插值算法可以通过一组散点得到一个符合一定规律插值器函数。若我们给插值器函数更多的散点x坐标序列，该函数将会返回相应的y坐标序列。

```python
func = si.interp1d(
    离散水平坐标, 
    离散垂直坐标,
    kind=插值算法(缺省为线性插值)
)
```

案例：

```python
# 插值操作示例
import numpy as np
import matplotlib.pyplot as mp
import scipy.interpolate as si

# 生成一组散点
min_x = -50
max_x = 50
x = np.linspace(min_x, max_x, 15)
y = np.sinc(x)

mp.scatter(x, y, s=60, color="dodgerblue", marker="o", label="Samples")

# 通过样本点生成插值器函数
linear = si.interp1d(x, y, kind="linear")
linear_x = np.linspace(min_x, max_x, 1000)  # 产生一组新的点
linear_y = linear(linear_x)  # 计算y值
mp.plot(linear_x, linear_y, color="green", label="linear interplt")

# 三次样条插值 （CUbic Spline Interpolation） 获得一条光滑曲线
cubic = si.interp1d(x, y, kind='cubic')
cub_x = np.linspace(min_x, max_x, 200)
cub_y = cubic(cub_x)
mp.plot(cub_x, cub_y, color="orangered", linestyle=":",
        linewidth=4, alpha=0.8, label="linear interplt")

mp.grid()
mp.legend()
mp.show()
```

执行结果：

![](images/interpolate.png)

插值和拟合的区别：

（1）拟合是给定了空间中的一些点，找到一个已知形式未知参数的连续曲面来最大限度地逼近这些点；而插值是找到一条直线或曲线穿过这些点；

（2）拟合是整体逼近，插值误差通常考虑的是逐点误差或最大模误差，插值的好坏往往通过某些局部的性质来体现。



### 3. 积分

直观地说，对于一个给定的正实值函数，在一个实数区间上的定积分可以理解为坐标平面上由曲线、直线以及轴围成的曲边梯形的面积值（一种确定的实数值）。

利用微元法认识什么是积分。

案例：

1. 在[-5, 5]区间绘制二次函数y=2x<sup>2</sup>+3x+4的曲线：

```python
import numpy as np
import matplotlib.pyplot as mp
import matplotlib.patches as mc
import scipy.integrate as si


def f(x):
    return 2 * x ** 2 + 3 * x + 4


a, b = -5, 5
x1 = np.linspace(a, b, 1001)
y1 = f(x1)

# 利用quad求积分 给出函数f，积分下限与积分上限[a, b]   返回(积分值，最大误差)
area = si.quad(f, a, b)[0]
print("area:", area)

mp.figure('Integral', facecolor='lightgray')
mp.title('Integral', fontsize=20)
mp.xlabel('x', fontsize=14)
mp.ylabel('y', fontsize=14)
mp.tick_params(labelsize=10)
mp.grid(linestyle=':')
mp.plot(x1, y1, c='orangered', linewidth=1, label=r'$y=2x^2+3x+4$', zorder=0)
mp.legend()
mp.show()
```

执行结果：

```
area: 206.66666666666669
```



### 4. 图像

scipy.ndimage中提供了一些简单的图像处理，如高斯模糊、任意角度旋转、边缘识别等功能。

```python
![ndimage](img/ndimage.png)import numpy as np
import scipy.misc as sm
import scipy.ndimage as sn
import matplotlib.pyplot as mp
#读取文件
original = sm.imread('../da_data/lily.jpg', True)
#高斯模糊
median = sn.median_filter(original, 21)
#角度旋转
rotate = sn.rotate(original, 45)
#边缘识别
prewitt = sn.prewitt(original)
mp.figure('Image', facecolor='lightgray')
mp.subplot(221)
mp.title('Original', fontsize=16)
mp.axis('off')
mp.imshow(original, cmap='gray')
mp.subplot(222)
mp.title('Median', fontsize=16)
mp.axis('off')
mp.imshow(median, cmap='gray')
mp.subplot(223)
mp.title('Rotate', fontsize=16)
mp.axis('off')
mp.imshow(rotate, cmap='gray')
mp.subplot(224)
mp.title('Prewitt', fontsize=16)
mp.axis('off')
mp.imshow(prewitt, cmap='gray')
mp.tight_layout()
mp.show()

```

执行结果：

![](images/ndimage.png)



### 5. 金融相关

```python
import numpy as np

# 计算终值
# 终值 = np.fv(利率, 期数, 每期支付, 现值)
# 返回期限结束时的值
# 将1000元以1%的年利率存入银行5年，每年加存100元，
# 到期后本息合计多少钱？
fv = np.fv(0.01,  # 利率
           5,  # 福利期数
           -100,  # 支付金额
           -1000)  # 现值
print("fv:", round(fv, 2))

# 计算现值
# 现值 = np.pv(利率, 期数, 每期支付, 终值)
# 将多少钱以1%的年利率存入银行5年，每年加存100元，
# 到期后本息合计fv元？
pv = np.pv(0.01, 5, -100, fv)
print("pv:", pv)

# 净现值 = np.npv(利率, 现金流)
# 将1000元以1%的年利率存入银行5年，每年加存100元，
# 相当于一次性存入多少钱？
npv = np.npv(0.01, [
    -1000, -100, -100, -100, -100, -100])
print("npv:", round(npv, 2))

# 每期支付 = np.pmt(利率, 期数, 现值)
# 以1%的年利率从银行贷款1000元，分5年还清，
# 平均每年还多少钱？
pmt = np.pmt(0.01, 5, 1000)
print("pmt:", round(pmt, 2))

# 期数 = np.nper(利率, 每期支付, 现值)
# 以1%的年利率从银行贷款1000元，平均每年还pmt元，
# 多少年还清？
nper = np.nper(0.01, pmt, 1000)
print("nper:", int(nper))

# 利率 = np.rate(期数, 每期支付, 现值, 终值)
# 从银行贷款1000元，平均每年还pmt元，nper年还清，
# 年利率多少？
rate = np.rate(nper, pmt, 1000, 0)
print("rate:", round(rate, 2))
```

执行结果：

```
fv: 1561.11
pv: -1000.0
npv: -1485.34
pmt: -206.04
nper: 5
rate: 0.01
```



































































































































































































































